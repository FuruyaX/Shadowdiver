<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>リアルタイム戦略ローグライク：ディープダイバー</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        // Firebaseのインポートとグローバル変数へのエクスポート (Canvas環境の要件)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, onSnapshot, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // グローバル変数として設定: メインスクリプトから参照できるようにする
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        window.getDocs = getDocs;
    </script>

    <style>
        /* カスタムCSS */
        body, html, #app-root {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
        }
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #main-canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* タッチイベントのデフォルト動作を無効化 */
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UI要素以外を操作できるようにする */
        }
        .minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: none;
            z-index: 10;
            border: 4px solid #4b5563;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        /* ロード画面/タイトル画面のスタイル */
        .full-screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #f3f4f6;
            z-index: 50;
            text-align: center;
        }

        /* ジョイスティックのスタイル */
        #joystick-base {
            position: absolute;
            bottom: 40px; /* 画面下からの距離 */
            left: 40px;  /* 画面左からの距離 */
            width: 120px;
            height: 120px;
            background-color: rgba(75, 85, 99, 0.5); /* gray-600/50 */
            border-radius: 50%;
            pointer-events: auto; /* タッチを有効にする */
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #joystick-thumb {
            width: 60px;
            height: 60px;
            background-color: rgba(239, 68, 68, 0.8); /* red-500/80 */
            border-radius: 50%;
            position: absolute;
            transform: translate(0, 0); /* JavaScriptで操作 */
        }
        
        /* 視点操作パッドのスタイル */
        #view-pad {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%; /* 画面右半分 */
            height: 100%;
            pointer-events: auto; /* タッチを有効にする */
            touch-action: none;
        }
    </style>
</head>
<body id="app-root">

    <!-- タイトル画面オーバーレイ -->
    <div id="title-screen" class="full-screen-overlay">
        <h1 class="text-6xl font-extrabold text-teal-400 mb-4 tracking-wider">DEEP DIVER</h1>
        <p class="text-xl text-gray-300 mb-12">リアルタイム戦略ローグライク</p>
        <button id="start-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-10 rounded-xl shadow-2xl transition duration-300 transform hover:scale-105 pointer-events-auto">
            ゲームスタート
        </button>
        <p id="firebase-status" class="mt-8 text-sm text-gray-500">
            データ永続化: 準備中...
        </p>
    </div>

    <!-- メインゲームコンテナ -->
    <div id="game-container" class="hidden">
        <!-- Three.js Canvas は JavaScript で挿入される -->
        
        <!-- UIオーバーレイ -->
        <div id="ui-overlay">
            
            <!-- ミニマップコンテナ (Three.jsのレンダリング領域として使用) -->
            <div id="minimap-container" class="minimap-container">
                <!-- Three.jsで直接描画するため、ここでは空のコンテナ -->
            </div>

            <!-- 左下の情報パネル -->
            <div class="absolute bottom-4 left-4 p-4 bg-gray-900/80 rounded-xl shadow-lg w-72">
                <div class="text-sm font-semibold text-gray-400 border-b border-gray-700 pb-1 mb-2">ステータス</div>
                <div class="space-y-1 text-white">
                    <div id="status-hp" class="flex justify-between">HP: <span class="text-red-400">100 / 100</span></div>
                    <div id="status-st" class="flex justify-between">ST: <span class="text-blue-400">100 / 100</span></div>
                    <div id="status-floor" class="flex justify-between">階層: <span class="text-yellow-400">B1F</span></div>
                </div>
                <div class="text-sm font-semibold text-gray-400 border-b border-gray-700 pt-3 pb-1 mt-3 mb-2">デバッグ情報</div>
                <div class="text-xs text-gray-400 space-y-0.5">
                    <p>FPS: <span id="fps-display">0</span></p>
                    <p>Pos: (<span id="pos-x">0.00</span>, <span id="pos-z">0.00</span>)</p>
                    <p id="nearest-obstacle">最寄りの障害物: 0.00 m</p>
                    <p>UserID: <span id="user-id-display">anon</span></p>
                </div>
            </div>

            <!-- メッセージログ -->
            <div id="message-log" class="absolute bottom-4 left-80 p-3 bg-gray-900/80 rounded-xl shadow-lg w-96 max-h-40 overflow-y-auto pointer-events-auto">
                <div class="text-xs space-y-0.5" id="log-messages">
                    <!-- メッセージがここに挿入される -->
                </div>
            </div>

            <!-- フローティングコントローラー (モバイル/タッチ用) -->
            <div id="touch-controls" class="md:hidden">
                <!-- 移動用ジョイスティック -->
                <div id="joystick-base">
                    <div id="joystick-thumb"></div>
                </div>
                <!-- 視点移動用タッチパッド -->
                <div id="view-pad"></div> 
            </div>
            
        </div>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="game-over-screen" class="full-screen-overlay hidden">
        <h1 class="text-6xl font-extrabold text-red-600 mb-4 tracking-wider">GAME OVER</h1>
        <p class="text-xl text-gray-300 mb-12">深層へのダイブは失敗に終わった...</p>
        <button id="restart-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-10 rounded-xl shadow-2xl transition duration-300 transform hover:scale-105 pointer-events-auto">
            再挑戦
        </button>
    </div>

    <script>
        // --- 定数定義 ---
        const CELL_SIZE = 5;          // ダンジョンのセルサイズ (メートル単位)
        const MAP_SIZE = 15;          // マップのセル数 (MAP_SIZE x MAP_SIZE)
        const WALL_HEIGHT = 4;        // 壁の高さ
        
        const BASE_MOVEMENT_SPEED = 5; // プレイヤーの基本移動速度 (5 単位/秒 に設定)
        const KEYBOARD_ROTATION_SPEED = 0.03; // キーボード旋回速度 (ラジアン/フレーム)
        const MOUSE_SENSITIVITY = 0.002; // マウス感度 (視点移動用)
        const TOUCH_LOOK_SENSITIVITY = 0.005; // タッチ感度 (視点移動用)
        const JOYSTICK_RADIUS = 60; // ジョイスティックの半径 (CSSと一致させる)

        const MINIMAP_SIZE = 200;     // ミニマップの固定サイズ (px)

        // ダミーのダンジョンマップ (0: 床, 1: 壁, 2: プレイヤー初期位置, 3: 敵)
        const DUNGEON_MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 3, 1], // 敵(3)を追加
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // --- グローバル変数 ---
        let camera, scene, renderer, player, minimapCamera;
        let keys = {}; // 入力状態 (WASD, 矢印キーなど)
        let animationId = null; // requestAnimationFrame ID
        let lastFrameTime = 0;
        let lastUpdateTime = 0;

        let gameState = 'title'; // 'title', 'playing', 'gameover'

        // Firebase関連
        let app, db, auth;
        let userId = 'anon';
        let isAuthReady = false;

        // タッチコントロール関連
        let activeTouches = {}; // タッチIDとタッチ情報のマッピング
        let joystickVec = { x: 0, y: 0 }; // ジョイスティックの移動ベクトル (-1.0 to 1.0)
        let joystickBaseElement, joystickThumbElement;

        // ダミーの敵データ (Three.jsのメッシュを含む)
        const enemies = [
            { id: 1, x: 13, z: 12, hp: 10, maxHp: 10, mesh: null }
        ];

        // --- ユーティリティ ---

        // Firebase初期化と認証処理 (変更なし: エラーハンドリングは前回の対応済み)
        async function initFirebase() {
            const statusElement = document.getElementById('firebase-status');
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            
            if (firebaseConfig) {
                try {
                    app = window.initializeApp(firebaseConfig); 
                    db = window.getFirestore(app);
                    auth = window.getAuth(app);
                    window.db = db;
                    window.auth = auth;

                    statusElement.textContent = "データ永続化: 認証中...";
                    
                    window.onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                        } else if (initialAuthToken) {
                            await window.signInWithCustomToken(auth, initialAuthToken);
                            userId = auth.currentUser.uid;
                        } else {
                            await window.signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                        }
                        
                        isAuthReady = true;
                        window.userId = userId;
                        document.getElementById('user-id-display').textContent = userId.substring(0, 8);
                        statusElement.textContent = `データ永続化: OK (User ID: ${userId.substring(0, 8)}...)`;
                        logMessage(`Firebase認証成功: User ID ${userId.substring(0, 8)}...`, 'info');
                    });
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    statusElement.textContent = "データ永続化: 失敗 (永続化なし)";
                    logMessage(`Firebase初期化エラー: ${error.name}: "${error.message}"。永続化なしで実行します。`, 'error');
                    isAuthReady = true;
                }
            } else {
                console.warn("Firebase config not available. Running game without persistence.");
                statusElement.textContent = "データ永続化: 設定なし (永続化なし)";
                logMessage("Firebase configが利用できません。永続化なしでゲームを実行します。", 'warn');
                isAuthReady = true;
            }
        }

        // メッセージログに出力
        function logMessage(message, type = 'log') {
            const logElement = document.getElementById('log-messages');
            if (!logElement) return;
            const time = new Date().toLocaleTimeString();
            const color = type === 'error' ? 'text-red-400' : 
                          type === 'warn' ? 'text-yellow-400' : 
                          type === 'info' ? 'text-blue-400' : 
                          'text-gray-200';
            const p = document.createElement('p');
            p.className = `text-xs ${color}`;
            p.innerHTML = `<span class="text-gray-500 mr-2">[${time}]</span> ${message}`;
            logElement.prepend(p);
            while (logElement.children.length > 20) {
                logElement.removeChild(logElement.lastChild);
            }
        }
        
        // --- 状態管理 (変更なし) ---
        function showTitleScreen() {
            gameState = 'title';
            document.getElementById('title-screen').classList.remove('hidden');
            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function showGameOverScreen() {
            gameState = 'gameover';
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            logMessage("GAME OVER: 深層へのダイブは失敗に終わった。", 'error');
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function startGame() {
            if (gameState === 'playing') return;

            gameState = 'playing';
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('game-container').classList.remove('hidden');

            if (!renderer) {
                initThree();
            }

            resetGame();

            lastFrameTime = performance.now();
            animate();

            // デスクトップの場合のみポインターロックを試みる
            if (!/Mobi|Android/i.test(navigator.userAgent)) {
                lockPointer();
            } else {
                 logMessage("タッチデバイスモード: ジョイスティックとスワイプで操作してください。", 'info');
            }
        }

        function resetGame() {
             const startPos = getStartPosition(DUNGEON_MAP);
             player.position.set(startPos.x, WALL_HEIGHT / 2, startPos.z);
             player.rotation.set(0, 0, 0); 
             camera.rotation.set(0, 0, 0); 
             keys = {};
             joystickVec = { x: 0, y: 0 }; // ジョイスティックもリセット

             enemies.forEach(enemy => {
                 if (enemy.mesh) {
                    const z = Math.floor(enemy.mesh.position.z / CELL_SIZE);
                    const x = Math.floor(enemy.mesh.position.x / CELL_SIZE);
                    if (DUNGEON_MAP[z][x] === 3) {
                         enemy.hp = enemy.maxHp;
                         enemy.mesh.visible = true;
                    }
                 }
             });

            logMessage("ゲームをリセットし、深層へのダイブを開始します。", 'info');
        }


        // --- Three.js 初期化 (変更なし) ---
        function initThree() {
            const container = document.getElementById('game-container');
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            player = new THREE.Group();
            player.add(camera); 
            scene.add(player);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x1f2937, 1);
            container.appendChild(renderer.domElement);
            renderer.domElement.id = 'main-canvas'; 

            renderer.autoClear = false; 
            renderer.setPixelRatio(window.devicePixelRatio);
            
            minimapCamera = new THREE.OrthographicCamera(
                -MAP_SIZE * CELL_SIZE / 2, MAP_SIZE * CELL_SIZE / 2,
                MAP_SIZE * CELL_SIZE / 2, -MAP_SIZE * CELL_SIZE / 2,
                0.1, 1000
            );
            minimapCamera.position.y = 50; 
            minimapCamera.rotation.x = -Math.PI / 2; 

            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 10, 0).normalize();
            scene.add(directionalLight);

            // 5. ジョイスティックUI要素の取得
            joystickBaseElement = document.getElementById('joystick-base');
            joystickThumbElement = document.getElementById('joystick-thumb');

            // 6. イベントリスナー
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleKeyDown, false);
            document.addEventListener('keyup', handleKeyUp, false);
            
            // デスクトップ操作のためのポインターロック
            renderer.domElement.addEventListener('click', lockPointer, false);

            // タッチ操作のためのイベントリスナー
            document.getElementById('game-container').addEventListener('touchstart', handleTouchStart, false);
            document.getElementById('game-container').addEventListener('touchmove', handleTouchMove, false);
            document.getElementById('game-container').addEventListener('touchend', handleTouchEnd, false);
            document.getElementById('game-container').addEventListener('touchcancel', handleTouchEnd, false);

            generateDungeonGeometry();
            onWindowResize(); 
        }

        function onWindowResize() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            
            const mapContainer = document.getElementById('minimap-container');
            const mapSize = Math.min(MINIMAP_SIZE, width / 4, height / 4);
            mapContainer.style.width = `${mapSize}px`;
            mapContainer.style.height = `${mapSize}px`;
        }
        
        // --- ジオメトリ生成/衝突判定 (変更なし) ---
        function generateDungeonGeometry() {
            scene.traverse(obj => {
                if (obj.userData.dungeonElement) {
                    scene.remove(obj);
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                }
            });
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x374151 });
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x1f2937 });
            const enemyMaterial = new THREE.MeshPhongMaterial({ color: 0xef4444 });
            const startPos = getStartPosition(DUNGEON_MAP);

            for (let z = 0; z < MAP_SIZE; z++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const cell = DUNGEON_MAP[z][x];
                    const worldX = (x - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2;
                    const worldZ = (z - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2;

                    const floorGeometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
                    floorGeometry.rotateX(-Math.PI / 2);
                    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                    floor.position.set(worldX, 0, worldZ);
                    floor.userData.dungeonElement = true;
                    scene.add(floor);

                    if (cell === 1) { 
                        const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(worldX, WALL_HEIGHT / 2, worldZ);
                        wall.userData.dungeonElement = true;
                        wall.userData.isWall = true;
                        scene.add(wall);
                    } else if (cell === 2) { 
                        if (player) {
                            player.position.set(worldX, WALL_HEIGHT / 2, worldZ);
                        }
                    } else if (cell === 3) {
                        const enemySize = CELL_SIZE * 0.5;
                        const enemyGeometry = new THREE.CylinderGeometry(enemySize / 2, enemySize / 2, enemySize, 8);
                        const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                        enemyMesh.position.set(worldX, enemySize / 2, worldZ);
                        enemyMesh.userData.dungeonElement = true;
                        scene.add(enemyMesh);
                        
                        const enemyData = enemies.find(e => Math.floor(e.x) === x && Math.floor(e.z) === z);
                        if (enemyData) {
                            enemyData.mesh = enemyMesh;
                            enemyData.mesh.visible = true;
                        }
                    }
                }
            }
        }

        function getStartPosition(map) {
            for (let z = 0; z < map.length; z++) {
                for (let x = 0; x < map[z].length; x++) {
                    if (map[z][x] === 2) {
                        return { 
                            x: (x - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2, 
                            z: (z - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2 
                        };
                    }
                }
            }
            return { x: 0, z: 0 }; 
        }

        function isWallCollision(worldX, worldZ) {
            const mapX = Math.floor(worldX / CELL_SIZE + MAP_SIZE / 2);
            const mapZ = Math.floor(worldZ / CELL_SIZE + MAP_SIZE / 2);

            if (mapX < 0 || mapX >= MAP_SIZE || mapZ < 0 || mapZ >= MAP_SIZE) {
                return true;
            }

            return DUNGEON_MAP[mapZ][mapX] === 1;
        }

        // --- 入力処理 (キーボード) ---

        function handleKeyDown(event) {
            if (gameState !== 'playing') return;
            keys[event.key.toLowerCase()] = true;
            if (event.key.startsWith('Arrow')) {
                 event.preventDefault(); // 矢印キーで画面がスクロールしないようにする
            }
        }

        function handleKeyUp(event) {
            if (gameState !== 'playing') return;
            keys[event.key.toLowerCase()] = false;
        }

        // --- 入力処理 (マウス/視点移動) ---
        
        function handleMouseMove(event) {
            if (gameState !== 'playing') return;

            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            // Yaw (Y軸回転: 左右を見る)
            player.rotation.y -= movementX * MOUSE_SENSITIVITY;
            
            // Pitch (X軸回転: 上下を見る)
            camera.rotation.x -= movementY * MOUSE_SENSITIVITY;
            
            // 垂直方向の視野を制限
            clampCameraPitch();
        }

        function lockPointer() {
            const canvas = renderer.domElement;
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.requestPointerLock();
            logMessage("メイン画面をクリックしました。マウスで視点移動が可能です。", 'info');
        }
        
        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);

        function pointerLockChange() {
            if (document.pointerLockElement === renderer.domElement ||
                document.mozPointerLockElement === renderer.domElement) {
                document.addEventListener('mousemove', handleMouseMove, false);
            } else {
                document.removeEventListener('mousemove', handleMouseMove, false);
                logMessage("ポインターロックが解除されました。Escキーを押したか、ブラウザを離れました。", 'warn');
            }
        }

        // --- 入力処理 (タッチ/ジョイスティック/スワイプ) ---

        function getTouchPos(touch) {
            const rect = renderer.domElement.getBoundingClientRect();
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function handleTouchStart(event) {
            if (gameState !== 'playing') return;
            
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const pos = getTouchPos(touch);
                
                // 画面の左右半分で処理を分ける
                if (pos.x < window.innerWidth / 2) {
                    // 左半分: ジョイスティック開始
                    if (joystickBaseElement) {
                         // ジョイスティックの座標を初期化 (初回タッチでジョイスティックが出現するロジックは今回無し)
                         // activeTouchesにジョイスティックIDを記録
                         activeTouches[touch.identifier] = { type: 'move', startX: pos.x, startY: pos.y, currentX: pos.x, currentY: pos.y };
                    }
                } else {
                    // 右半分: 視点移動開始
                    activeTouches[touch.identifier] = { type: 'look', startX: pos.x, startY: pos.y, currentX: pos.x, currentY: pos.y };
                }
            }
            event.preventDefault();
        }

        function handleTouchMove(event) {
            if (gameState !== 'playing') return;

            let lookX = 0;
            let lookY = 0;
            let moveDeltaX = 0;
            let moveDeltaY = 0;

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const pos = getTouchPos(touch);
                const activeTouch = activeTouches[touch.identifier];

                if (activeTouch) {
                    activeTouch.currentX = pos.x;
                    activeTouch.currentY = pos.y;
                    
                    if (activeTouch.type === 'move') {
                        // ジョイスティック処理
                        moveDeltaX = pos.x - activeTouch.startX;
                        moveDeltaY = pos.y - activeTouch.startY;

                        // 半径でクランプ
                        const dist = Math.sqrt(moveDeltaX * moveDeltaX + moveDeltaY * moveDeltaY);
                        if (dist > JOYSTICK_RADIUS) {
                            moveDeltaX *= JOYSTICK_RADIUS / dist;
                            moveDeltaY *= JOYSTICK_RADIUS / dist;
                        }

                        // ジョイスティックベクトルの更新 (-1.0 to 1.0)
                        joystickVec.x = moveDeltaX / JOYSTICK_RADIUS;
                        joystickVec.y = moveDeltaY / JOYSTICK_RADIUS;

                        // サムの位置を更新 (CSS)
                        if (joystickThumbElement) {
                             joystickThumbElement.style.transform = `translate(${moveDeltaX}px, ${moveDeltaY}px)`;
                        }

                    } else if (activeTouch.type === 'look') {
                        // 視点移動処理 (スワイプ)
                        lookX += pos.x - activeTouch.startX;
                        lookY += pos.y - activeTouch.startY;
                        
                        // 視点移動は絶対位置ではなくデルタを追跡し、次のフレームで初期化 (リセット)
                        // ここではデルタを保持する
                    }
                }
            }
            
            // スワイプによる視点移動を適用
            if (lookX !== 0 || lookY !== 0) {
                 player.rotation.y -= lookX * TOUCH_LOOK_SENSITIVITY;
                 camera.rotation.x -= lookY * TOUCH_LOOK_SENSITIVITY;
                 clampCameraPitch();
                 
                 // スワイプ視点移動後、次のフレームのために開始位置を更新して連続的なスワイプを可能にする
                 for (let i = 0; i < event.changedTouches.length; i++) {
                    const touch = event.changedTouches[i];
                    const activeTouch = activeTouches[touch.identifier];
                    if (activeTouch && activeTouch.type === 'look') {
                         activeTouch.startX = activeTouch.currentX;
                         activeTouch.startY = activeTouch.currentY;
                    }
                 }
            }

            event.preventDefault();
        }

        function handleTouchEnd(event) {
            if (gameState !== 'playing') return;

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const activeTouch = activeTouches[touch.identifier];

                if (activeTouch && activeTouch.type === 'move') {
                    // ジョイスティックを中央に戻す
                    joystickVec = { x: 0, y: 0 };
                    if (joystickThumbElement) {
                        joystickThumbElement.style.transform = `translate(0, 0)`;
                    }
                }
                
                // タッチ情報を削除
                delete activeTouches[touch.identifier];
            }
        }
        
        function clampCameraPitch() {
             const maxPitch = Math.PI / 2 - 0.01;
             const minPitch = -Math.PI / 2 + 0.01;
             camera.rotation.x = Math.max(minPitch, Math.min(maxPitch, camera.rotation.x));
        }

        // --- ゲームループ & 更新ロジック ---

        function animate() {
            animationId = requestAnimationFrame(animate);

            if (gameState !== 'playing') return;

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000; // 秒単位
            lastFrameTime = currentTime;
            
            updateGame(deltaTime); 

            updateUI(deltaTime);

            renderScene();
        }

        function updateGame(deltaTime) {
            // 移動速度は単位/秒で計算する
            const speed = BASE_MOVEMENT_SPEED * deltaTime;
            let moveX = 0;
            let moveZ = 0;
            
            const angle = player.rotation.y;
            
            // --- 1. キーボード/マウス入力による移動 ---
            if (keys['w']) { // 前進
                moveX += Math.sin(angle) * speed;
                moveZ += Math.cos(angle) * speed;
            }
            if (keys['s']) { // 後退
                moveX -= Math.sin(angle) * speed;
                moveZ -= Math.cos(angle) * speed;
            }
            if (keys['a']) { // 左に平行移動
                moveX -= Math.sin(angle - Math.PI / 2) * speed * 0.5;
                moveZ -= Math.cos(angle - Math.PI / 2) * speed * 0.5;
            }
            if (keys['d']) { // 右に平行移動
                moveX += Math.sin(angle - Math.PI / 2) * speed * 0.5;
                moveZ += Math.cos(angle - Math.PI / 2) * speed * 0.5;
            }

            // --- 2. タッチ/ジョイスティック入力による移動 ---
            if (joystickVec.x !== 0 || joystickVec.y !== 0) {
                // Joystick input is a vector relative to the screen,
                // so Y (forward/backward) is usually negative for "up" movement
                const forward = -joystickVec.y * speed; 
                const right = joystickVec.x * speed * 0.5; // Strafe speed is halved

                // Forward/Backward component (aligned with player look)
                moveX += Math.sin(angle) * forward;
                moveZ += Math.cos(angle) * forward;
                
                // Strafe component (perpendicular to player look)
                moveX += Math.sin(angle - Math.PI / 2) * right;
                moveZ += Math.cos(angle - Math.PI / 2) * right;
            }
            
            // --- 3. キーボード/矢印キーによる視点移動 ---
            const rotationSpeed = KEYBOARD_ROTATION_SPEED; // 単位はラジアン/フレーム
            
            if (keys['arrowleft']) {
                player.rotation.y += rotationSpeed;
            }
            if (keys['arrowright']) {
                player.rotation.y -= rotationSpeed;
            }
            if (keys['arrowup']) {
                camera.rotation.x += rotationSpeed * 0.5; // ピッチは少し遅く
            }
            if (keys['arrowdown']) {
                camera.rotation.x -= rotationSpeed * 0.5;
            }
            clampCameraPitch();


            // --- 4. 衝突判定と移動の適用 ---
            let newX = player.position.x + moveX;
            let newZ = player.position.z + moveZ;
            
            if (!isWallCollision(newX, player.position.z)) {
                player.position.x = newX;
            } else if (moveX !== 0) {
                // logMessage("壁にぶつかりました (X方向)。", 'warn');
            }

            if (!isWallCollision(player.position.x, newZ)) {
                player.position.z = newZ;
            } else if (moveZ !== 0) {
                // logMessage("壁にぶつかりました (Z方向)。", 'warn');
            }
            
            // 敵のダミー更新 (変更なし)
            enemies.forEach(enemy => {
                if (enemy.mesh && enemy.mesh.visible) {
                    const dx = player.position.x - enemy.mesh.position.x;
                    const dz = player.position.z - enemy.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist > 1) { 
                        const factor = 0.5 * deltaTime; // 敵の移動速度 (0.5単位/秒)
                        enemy.mesh.position.x += dx / dist * factor;
                        enemy.mesh.position.z += dz / dist * factor;
                        
                        enemy.mesh.rotation.y = Math.atan2(dx, dz);
                    } else if (dist < 0.5) {
                        showGameOverScreen();
                    }
                }
            });
        }

        // --- 描画/UI (変更なし) ---
        function findClosestObstacle() {
            let minDistance = Infinity;
            let playerX = player.position.x;
            let playerZ = player.position.z;

            for (let z = 0; z < MAP_SIZE; z++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (DUNGEON_MAP[z][x] === 1) { 
                        const wallWorldX = (x - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2;
                        const wallWorldZ = (z - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2;

                        const dx = wallWorldX - playerX;
                        const dz = wallWorldZ - playerZ;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        const distanceToWallEdge = distance - CELL_SIZE / 2;
                        
                        if (distanceToWallEdge > 0 && distanceToWallEdge < minDistance) {
                            minDistance = distanceToWallEdge;
                        }
                    }
                }
            }
            return { distance: minDistance === Infinity ? 0 : minDistance };
        }

        function renderScene() {
            const mainWidth = renderer.domElement.width;
            const mainHeight = renderer.domElement.height;
            
            renderer.setViewport(0, 0, mainWidth, mainHeight);
            renderer.setScissor(0, 0, mainWidth, mainHeight);
            renderer.setClearColor(0x111827, 1);
            renderer.clear();
            
            renderer.render(scene, camera);

            const mapContainer = document.getElementById('minimap-container');
            if (mapContainer) {
                const mapSize = mapContainer.clientWidth;
                const mapX = mainWidth - mapSize - 20;
                const mapY = mainHeight - mapSize - 20; 

                renderer.setViewport(mapX, mapY, mapSize, mapSize);
                renderer.setScissor(mapX, mapY, mapSize, mapSize);
                renderer.setScissorTest(true);

                renderer.setClearColor(0x1f2937, 1);
                renderer.clear();

                minimapCamera.position.x = player.position.x;
                minimapCamera.position.z = player.position.z;

                renderer.render(scene, minimapCamera);
                
                renderer.setScissorTest(false);
            }
        }

        function updateUI(deltaTime) {
            const currentTime = performance.now();
            if (lastUpdateTime > 0) {
                const fps = 1000 / (currentTime - lastUpdateTime);
                document.getElementById('fps-display').textContent = Math.round(fps);
            }
            lastUpdateTime = currentTime;

            document.getElementById('pos-x').textContent = player.position.x.toFixed(2);
            document.getElementById('pos-z').textContent = player.position.z.toFixed(2);
            
            const closest = findClosestObstacle();
            document.getElementById('nearest-obstacle').textContent = `最寄りの障害物: ${closest.distance.toFixed(2)} m`;
        }


        // --- エントリポイント ---
        window.onload = function () {
            initFirebase();
            
            document.getElementById('start-button').addEventListener('click', startGame, false);
            document.getElementById('restart-button').addEventListener('click', startGame, false);

            showTitleScreen();
        }
    </script>
</body>
</html>
