<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>リアルタイム戦略ローグライク：ディープダイバー</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        // Firebaseのインポートとグローバル変数へのエクスポート (Canvas環境の要件)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, onSnapshot, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // グローバル変数として設定: メインスクリプトから参照できるようにする
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;
        window.getDocs = getDocs;
    </script>

    <style>
        /* カスタムCSS */
        body, html, #app-root {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
        }
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #main-canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* タッチイベントのデフォルト動作を無効化 */
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UI要素以外を操作できるようにする */
        }
        .minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: none;
            z-index: 10;
            border: 4px solid #4b5563;
            border-radius: 0.5rem;
            overflow: hidden;
        }
        /* ロード画面/タイトル画面のスタイル */
        .full-screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #f3f4f6;
            z-index: 50;
            text-align: center;
        }
        /* タイトルメニューボタンのスタイル */
        .menu-button {
            @apply bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-8 rounded-xl shadow-lg transition duration-300 w-64 mb-3 pointer-events-auto;
        }
        .menu-button:disabled {
            @apply bg-gray-800 text-gray-500 cursor-not-allowed;
        }

        /* ジョイスティックのスタイル */
        #joystick-base {
            position: absolute;
            bottom: 40px; /* 画面下からの距離 */
            left: 40px;  /* 画面左からの距離 */
            width: 120px;
            height: 120px;
            background-color: rgba(75, 85, 99, 0.5); /* gray-600/50 */
            border-radius: 50%;
            pointer-events: auto; /* タッチを有効にする */
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #joystick-thumb {
            width: 60px;
            height: 60px;
            background-color: rgba(239, 68, 68, 0.8); /* red-500/80 */
            border-radius: 50%;
            position: absolute;
            transform: translate(0, 0); /* JavaScriptで操作 */
        }
        
        /* 視点操作パッドのスタイル */
        #view-pad {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%; /* 画面右半分 */
            height: 100%;
            pointer-events: auto; /* タッチを有効にする */
            touch-action: none;
        }

        /* プレイヤーアイコンをミニマップキャンバスに描画するため、ここではカスタムCSSは不要 */
    </style>
</head>
<body id="app-root">

    <!-- タイトル画面オーバーレイ -->
    <div id="title-screen" class="full-screen-overlay">
        <h1 class="text-6xl font-extrabold text-teal-400 mb-4 tracking-wider">DEEP DIVER</h1>
        <p class="text-xl text-gray-300 mb-12">リアルタイム戦略ローグライク</p>
        
        <div id="menu-container" class="space-y-3">
            <button id="menu-new-game" class="menu-button bg-red-600 hover:bg-red-700">初めから</button>
            <button id="menu-continue" class="menu-button" disabled>続きから (未実装)</button>
            <button id="menu-controls" class="menu-button">操作方法</button>

            <!-- モード選択 (三択) -->
            <div id="game-mode-selector" class="mt-6">
                <p class="text-lg text-gray-400 mb-2">ゲームモード:</p>
                <div class="flex justify-center space-x-2 p-2 bg-gray-800/70 rounded-xl">
                    <button data-mode="story" class="mode-option text-sm py-2 px-4 rounded-lg transition" style="background-color: #0d9488;">ストーリー</button>
                    <button data-mode="plunder" class="mode-option text-sm py-2 px-4 rounded-lg transition bg-gray-700">盗掘</button>
                    <button data-mode="endless" class="mode-option text-sm py-2 px-4 rounded-lg transition bg-gray-700">エンドレス</button>
                </div>
            </div>
        </div>
        
        <p id="firebase-status" class="mt-8 text-sm text-gray-500">
            データ永続化: 準備中...
        </p>
    </div>
    
    <!-- 操作方法モーダル (ゲーム内警告にも流用) -->
    <div id="control-modal" class="full-screen-overlay hidden">
        <div class="bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-lg">
            <h2 class="text-3xl font-bold text-teal-400 mb-4" id="modal-title">操作方法</h2>
            <div id="modal-content" class="text-left text-gray-300 space-y-3">
                <p class="font-bold border-b border-gray-600 pb-1 mb-2">移動・視点操作 (PC)</p>
                <ul class="list-disc list-inside space-y-1 ml-4 text-sm">
                    <li>**移動**: W/A/S/D キー</li>
                    <li>**視点移動**: マウスドラッグ (ポインターロック時) または 矢印キー</li>
                    <li>**ダッシュ**: Shift キー (移動速度1.5倍)</li>
                </ul>
                <p class="font-bold border-b border-gray-600 pb-1 pt-3 mb-2">アクションショートカット (PC)</p>
                <ul class="list-disc list-inside space-y-1 ml-4 text-sm">
                    <li>**攻撃**: Space キー</li>
                    <li>**アイテム使用**: E キー</li>
                    <li>**探索**: F キー</li>
                    <li>**待機**: Z キー</li>
                </ul>
                <p class="font-bold border-b border-gray-600 pb-1 pt-3 mb-2">タッチ操作 (モバイル)</p>
                <ul class="list-disc list-inside space-y-1 ml-4 text-sm">
                    <li>**移動**: 画面左下のフローティングジョイスティック</li>
                    <li>**視点移動**: 画面右側のスワイプ</li>
                </ul>
            </div>
            <button id="close-modal-button" class="mt-8 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg pointer-events-auto">閉じる</button>
        </div>
    </div>


    <!-- メインゲームコンテナ -->
    <div id="game-container" class="hidden">
        <!-- Three.js Canvas は JavaScript で挿入される -->
        
        <!-- UIオーバーレイ -->
        <div id="ui-overlay">
            
            <!-- ミニマップコンテナ (Three.jsのレンダリング領域として使用) -->
            <div id="minimap-container" class="minimap-container">
                <!-- ミニマップキャンバスをここに挿入 -->
            </div>

            <!-- 左下の情報パネル -->
            <div class="absolute bottom-4 left-4 p-4 bg-gray-900/80 rounded-xl shadow-lg w-72">
                <div class="text-sm font-semibold text-gray-400 border-b border-gray-700 pb-1 mb-2">ステータス</div>
                <div class="space-y-1 text-white">
                    <div id="status-hp" class="flex justify-between">HP: <span class="text-red-400">100 / 100</span></div>
                    <div id="status-st" class="flex justify-between">ST: <span class="text-blue-400">100 / 100</span></div>
                    <div id="status-floor" class="flex justify-between">階層: <span class="text-yellow-400">B1F</span></div>
                    <div id="status-mode" class="flex justify-between">モード: <span class="text-teal-400">ストーリー</span></div>
                </div>
                <div class="text-sm font-semibold text-gray-400 border-b border-gray-700 pt-3 pb-1 mt-3 mb-2">デバッグ情報</div>
                <div class="text-xs text-gray-400 space-y-0.5">
                    <p>FPS: <span id="fps-display">0</span></p>
                    <p>Pos: (<span id="pos-x">0.00</span>, <span id="pos-z">0.00</span>)</p>
                    <p id="nearest-obstacle">最寄りの障害物: 0.00 m</p>
                    <p>UserID: <span id="user-id-display">anon</span></p>
                    <p>Dash: <span id="dash-status" class="text-red-400">OFF</span></p>
                </div>
            </div>
            
            <!-- メッセージログ -->
            <div id="message-log" class="absolute bottom-4 left-80 p-3 bg-gray-900/80 rounded-xl shadow-lg w-96 max-h-40 overflow-y-auto pointer-events-auto">
                <div class="text-xs space-y-0.5" id="log-messages">
                    <!-- メッセージがここに挿入される -->
                </div>
            </div>

            <!-- フローティングコントローラー (モバイル/タッチ用) -->
            <div id="touch-controls" class="md:hidden">
                <!-- 移動用ジョイスティック -->
                <div id="joystick-base">
                    <div id="joystick-thumb"></div>
                </div>
                <!-- 視点移動用タッチパッド -->
                <div id="view-pad"></div> 
            </div>
            
        </div>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="game-over-screen" class="full-screen-overlay hidden">
        <h1 class="text-6xl font-extrabold text-red-600 mb-4 tracking-wider">GAME OVER</h1>
        <p class="text-xl text-gray-300 mb-12">深層へのダイブは失敗に終わった...</p>
        <button id="restart-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-4 px-10 rounded-xl shadow-2xl transition duration-300 transform hover:scale-105 pointer-events-auto">
            再挑戦
        </button>
    </div>

    <script>
        // --- 定数定義 ---
        const CELL_SIZE = 5;          // ダンジョンのセルサイズ (メートル単位)
        const MAP_SIZE = 15;          // マップのセル数 (MAP_SIZE x MAP_SIZE)
        const WALL_HEIGHT = 4;        // 壁の高さ
        
        const BASE_MOVEMENT_SPEED = 5; // プレイヤーの基本移動速度 (5 単位/秒)
        const DASH_MULTIPLIER = 1.5;   // ダッシュ時の速度倍率
        const KEYBOARD_ROTATION_SPEED = 0.03; // キーボード旋回速度 (ラジアン/フレーム)
        const MOUSE_SENSITIVITY = 0.002; // マウス感度 (視点移動用)
        const TOUCH_LOOK_SENSITIVITY = 0.005; // タッチ感度 (視点移動用)
        const JOYSTICK_RADIUS = 60; // ジョイスティックの半径 (CSSと一致させる)

        const MINIMAP_SIZE = 200;     // ミニマップの固定サイズ (px)
        const PLAYER_COLOR = 0x38bdf8; // sky-400

        // ダミーのダンジョンマップ (0: 床, 1: 壁, 2: プレイヤー初期位置, 3: 敵)
        const DUNGEON_MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 3, 1], // 敵(3)を追加
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // --- グローバル変数 ---
        let camera, scene, renderer, player, minimapCamera;
        let minimapScene, minimapRenderer; // ミニマップ専用のシーンとレンダラー
        let keys = {}; // 入力状態
        let animationId = null; 
        let lastFrameTime = 0;
        let lastUpdateTime = 0;

        let gameState = 'title'; // 'title', 'playing', 'gameover'
        let currentMode = 'story'; // 'story', 'plunder', 'endless'
        let isDashing = false; // ダッシュ状態

        // Firebase関連 (前回からの変更なし)
        let app, db, auth;
        let userId = 'anon';
        let isAuthReady = false;

        // タッチコントロール関連 (前回からの変更なし)
        let activeTouches = {}; 
        let joystickVec = { x: 0, y: 0 }; 
        let joystickBaseElement, joystickThumbElement;
        
        // ミニマッププレイヤーマーカー
        let playerMarker; 

        // ダミーの敵データ (Three.jsのメッシュを含む)
        const enemies = [
            { id: 1, x: 13, z: 12, hp: 10, maxHp: 10, mesh: null }
        ];

        // --- ユーティリティ ---
        async function initFirebase() { /* ... 変更なし ... */ 
            const statusElement = document.getElementById('firebase-status');
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
            
            if (firebaseConfig) {
                try {
                    app = window.initializeApp(firebaseConfig); 
                    db = window.getFirestore(app);
                    auth = window.getAuth(app);
                    window.db = db;
                    window.auth = auth;

                    statusElement.textContent = "データ永続化: 認証中...";
                    
                    window.onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                        } else if (initialAuthToken) {
                            await window.signInWithCustomToken(auth, initialAuthToken);
                            userId = auth.currentUser.uid;
                        } else {
                            await window.signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                        }
                        
                        isAuthReady = true;
                        window.userId = userId;
                        document.getElementById('user-id-display').textContent = userId.substring(0, 8);
                        statusElement.textContent = `データ永続化: OK (User ID: ${userId.substring(0, 8)}...)`;
                        logMessage(`Firebase認証成功: User ID ${userId.substring(0, 8)}...`, 'info');
                    });
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    statusElement.textContent = "データ永続化: 失敗 (永続化なし)";
                    logMessage(`Firebase初期化エラー: ${error.name}: "${error.message}"。永続化なしで実行します。`, 'error');
                    isAuthReady = true;
                }
            } else {
                console.warn("Firebase config not available. Running game without persistence.");
                statusElement.textContent = "データ永続化: 設定なし (永続化なし)";
                logMessage("Firebase configが利用できません。永続化なしでゲームを実行します。", 'warn');
                isAuthReady = true;
            }
        }
        
        function logMessage(message, type = 'log') {
            const logElement = document.getElementById('log-messages');
            if (!logElement) return;
            const time = new Date().toLocaleTimeString();
            const color = type === 'error' ? 'text-red-400' : 
                          type === 'warn' ? 'text-yellow-400' : 
                          type === 'info' ? 'text-blue-400' : 
                          'text-gray-200';
            const p = document.createElement('p');
            p.className = `text-xs ${color}`;
            p.innerHTML = `<span class="text-gray-500 mr-2">[${time}]</span> ${message}`;
            logElement.prepend(p);
            while (logElement.children.length > 20) {
                logElement.removeChild(logElement.lastChild);
            }
        }
        
        // --- 状態管理 ---
        function showTitleScreen() {
            gameState = 'title';
            document.getElementById('title-screen').classList.remove('hidden');
            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('control-modal').classList.add('hidden');
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        function showControlModal() {
            document.getElementById('modal-title').textContent = "操作方法";
            // コンテンツはHTML内にハードコード済み
            document.getElementById('control-modal').classList.remove('hidden');
        }

        function showGameOverScreen() {
            gameState = 'gameover';
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            logMessage("GAME OVER: 深層へのダイブは失敗に終わった。", 'error');
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function startGame() {
            if (gameState === 'playing') return;

            gameState = 'playing';
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('control-modal').classList.add('hidden');
            document.getElementById('game-container').classList.remove('hidden');

            if (!renderer) {
                initThree();
            }

            // モード表示の更新
            document.getElementById('status-mode').querySelector('span').textContent = currentMode === 'plunder' ? '盗掘' : currentMode === 'endless' ? 'エンドレス' : 'ストーリー';

            resetGame();

            lastFrameTime = performance.now();
            animate();

            if (!/Mobi|Android/i.test(navigator.userAgent)) {
                lockPointer();
            } else {
                 logMessage("タッチデバイスモード: ジョイスティックとスワイプで操作してください。", 'info');
            }
        }

        function resetGame() {
             const startPos = getStartPosition(DUNGEON_MAP);
             player.position.set(startPos.x, WALL_HEIGHT / 2, startPos.z);
             player.rotation.set(0, 0, 0); 
             camera.rotation.set(0, 0, 0); 
             keys = {};
             joystickVec = { x: 0, y: 0 }; 
             isDashing = false;
             
             // 敵のリセット
             enemies.forEach(enemy => {
                 if (enemy.mesh) {
                    enemy.hp = enemy.maxHp;
                    enemy.mesh.visible = true;
                    // 位置リセットはgenerateDungeonGeometryに任せる
                 }
             });

            logMessage(`ゲームをリセットしました。(モード: ${currentMode})`, 'info');
        }


        // --- Three.js 初期化 ---
        function initThree() {
            const container = document.getElementById('game-container');
            
            // 1. メインシーンとカメラ
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            player = new THREE.Group();
            player.add(camera); 
            scene.add(player);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x1f2937, 1);
            container.appendChild(renderer.domElement);
            renderer.domElement.id = 'main-canvas'; 

            renderer.autoClear = false; 
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // 2. ミニマップカメラ
            minimapCamera = new THREE.OrthographicCamera(
                -MAP_SIZE * CELL_SIZE / 2, MAP_SIZE * CELL_SIZE / 2,
                MAP_SIZE * CELL_SIZE / 2, -MAP_SIZE * CELL_SIZE / 2,
                0.1, 1000
            );
            minimapCamera.position.y = 50; 
            minimapCamera.rotation.x = -Math.PI / 2; 
            
            // 3. ミニマップ用プレイヤーマーカーの作成 (Three.jsオブジェクト)
            const markerGeometry = new THREE.ConeGeometry(CELL_SIZE * 0.2, CELL_SIZE * 0.6, 32);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: PLAYER_COLOR });
            playerMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            playerMarker.rotation.x = Math.PI / 2; // X-Z平面に平らにする
            playerMarker.position.y = 0.1; // 床の上に浮かせる
            playerMarker.userData.dungeonElement = true; // クリーンアップ対象
            scene.add(playerMarker);


            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 10, 0).normalize();
            scene.add(directionalLight);

            // 4. UI要素の取得とイベントリスナー
            joystickBaseElement = document.getElementById('joystick-base');
            joystickThumbElement = document.getElementById('joystick-thumb');

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleKeyDown, false);
            document.addEventListener('keyup', handleKeyUp, false);
            
            renderer.domElement.addEventListener('click', lockPointer, false);

            document.getElementById('game-container').addEventListener('touchstart', handleTouchStart, false);
            document.getElementById('game-container').addEventListener('touchmove', handleTouchMove, false);
            document.getElementById('game-container').addEventListener('touchend', handleTouchEnd, false);
            document.getElementById('game-container').addEventListener('touchcancel', handleTouchEnd, false);

            generateDungeonGeometry();
            onWindowResize(); 
        }

        function onWindowResize() {
            const container = document.getElementById('game-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            
            const mapContainer = document.getElementById('minimap-container');
            const mapSize = Math.min(MINIMAP_SIZE, width / 4, height / 4);
            mapContainer.style.width = `${mapSize}px`;
            mapContainer.style.height = `${mapSize}px`;
        }
        
        // --- ジオメトリ生成/衝突判定 (変更なし) ---
        function generateDungeonGeometry() {
            scene.traverse(obj => {
                if (obj.userData.dungeonElement) {
                    if (obj !== playerMarker) { // プレイヤーマーカーは残す
                        scene.remove(obj);
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) obj.material.dispose();
                    }
                }
            });
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x374151 });
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x1f2937 });
            const enemyMaterial = new THREE.MeshPhongMaterial({ color: 0xef4444 });
            const startPos = getStartPosition(DUNGEON_MAP);

            for (let z = 0; z < MAP_SIZE; z++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const cell = DUNGEON_MAP[z][x];
                    const worldX = (x - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2;
                    const worldZ = (z - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2;

                    const floorGeometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
                    floorGeometry.rotateX(-Math.PI / 2);
                    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                    floor.position.set(worldX, 0, worldZ);
                    floor.userData.dungeonElement = true;
                    scene.add(floor);

                    if (cell === 1) { 
                        const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(worldX, WALL_HEIGHT / 2, worldZ);
                        wall.userData.dungeonElement = true;
                        wall.userData.isWall = true;
                        scene.add(wall);
                    } else if (cell === 2) { 
                        if (player) {
                            player.position.set(worldX, WALL_HEIGHT / 2, worldZ);
                        }
                    } else if (cell === 3) {
                        const enemySize = CELL_SIZE * 0.5;
                        const enemyGeometry = new THREE.CylinderGeometry(enemySize / 2, enemySize / 2, enemySize, 8);
                        const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                        enemyMesh.position.set(worldX, enemySize / 2, worldZ);
                        enemyMesh.userData.dungeonElement = true;
                        scene.add(enemyMesh);
                        
                        const enemyData = enemies.find(e => Math.floor(e.x) === x && Math.floor(e.z) === z);
                        if (enemyData) {
                            enemyData.mesh = enemyMesh;
                            enemyData.mesh.visible = true;
                        }
                    }
                }
            }
        }

        function getStartPosition(map) {
            for (let z = 0; z < map.length; z++) {
                for (let x = 0; x < map[z].length; x++) {
                    if (map[z][x] === 2) {
                        return { 
                            x: (x - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2, 
                            z: (z - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2 
                        };
                    }
                }
            }
            return { x: 0, z: 0 }; 
        }

        function isWallCollision(worldX, worldZ) {
            const mapX = Math.floor(worldX / CELL_SIZE + MAP_SIZE / 2);
            const mapZ = Math.floor(worldZ / CELL_SIZE + MAP_SIZE / 2);

            if (mapX < 0 || mapX >= MAP_SIZE || mapZ < 0 || mapZ >= MAP_SIZE) {
                return true;
            }

            return DUNGEON_MAP[mapZ][mapX] === 1;
        }

        // --- 入力処理 (キーボード) ---

        function handleKeyDown(event) {
            if (gameState !== 'playing') {
                if (event.key === 'Escape' && document.getElementById('control-modal').classList.contains('hidden')) {
                     showTitleScreen(); // タイトル画面に戻る
                }
                return;
            }
            
            const key = event.key.toLowerCase();
            keys[key] = true;

            // ダッシュ判定
            if (key === 'shift') {
                isDashing = true;
            }
            
            // ショートカットキー処理
            switch(key) {
                case ' ': // スペースキー: 攻撃
                    event.preventDefault(); // 画面スクロール防止
                    logMessage("アクション: 攻撃！ (ヘイト上昇: 大)", 'info');
                    break;
                case 'e': // アイテム使用
                    logMessage("アクション: アイテムを使用しました。", 'info');
                    break;
                case 'f': // 探索
                    logMessage("アクション: 周囲を探索します。 (時間消費)", 'info');
                    break;
                case 'z': // 待機
                    logMessage("アクション: 待機。ST回復を待ちます。", 'info');
                    break;
            }

            if (event.key.startsWith('Arrow')) {
                 event.preventDefault(); 
            }
        }

        function handleKeyUp(event) {
            if (gameState !== 'playing') return;
            const key = event.key.toLowerCase();
            keys[key] = false;
            
            if (key === 'shift') {
                isDashing = false;
            }
        }

        // --- 入力処理 (マウス/視点移動) ---
        
        function handleMouseMove(event) {
            if (gameState !== 'playing') return;

            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            // Yaw (Y軸回転: 左右を見る)
            player.rotation.y -= movementX * MOUSE_SENSITIVITY;
            
            // Pitch (X軸回転: 上下を見る)
            camera.rotation.x -= movementY * MOUSE_SENSITIVITY;
            
            clampCameraPitch();
        }

        function lockPointer() {
            const canvas = renderer.domElement;
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.requestPointerLock();
            logMessage("メイン画面をクリックしました。マウスで視点移動が可能です。", 'info');
        }
        
        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);

        function pointerLockChange() {
            if (document.pointerLockElement === renderer.domElement ||
                document.mozPointerLockElement === renderer.domElement) {
                document.addEventListener('mousemove', handleMouseMove, false);
            } else {
                document.removeEventListener('mousemove', handleMouseMove, false);
                logMessage("ポインターロックが解除されました。Escキーを押したか、ブラウザを離れました。", 'warn');
            }
        }

        // --- 入力処理 (タッチ/ジョイスティック/スワイプ) ---

        function getTouchPos(touch) {
            const rect = renderer.domElement.getBoundingClientRect();
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function handleTouchStart(event) {
            if (gameState !== 'playing') return;
            
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const pos = getTouchPos(touch);
                
                if (pos.x < window.innerWidth / 2) {
                    // 左半分: ジョイスティック開始
                    activeTouches[touch.identifier] = { type: 'move', startX: pos.x, startY: pos.y, currentX: pos.x, currentY: pos.y };
                } else {
                    // 右半分: 視点移動開始
                    activeTouches[touch.identifier] = { type: 'look', startX: pos.x, startY: pos.y, currentX: pos.x, currentY: pos.y };
                }
            }
            event.preventDefault();
        }

        function handleTouchMove(event) {
            if (gameState !== 'playing') return;

            let lookX = 0;
            let lookY = 0;
            let moveDeltaX = 0;
            let moveDeltaY = 0;

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const pos = getTouchPos(touch);
                const activeTouch = activeTouches[touch.identifier];

                if (activeTouch) {
                    activeTouch.currentX = pos.x;
                    activeTouch.currentY = pos.y;
                    
                    if (activeTouch.type === 'move') {
                        // ジョイスティック処理
                        moveDeltaX = pos.x - activeTouch.startX;
                        moveDeltaY = pos.y - activeTouch.startY;

                        const dist = Math.sqrt(moveDeltaX * moveDeltaX + moveDeltaY * moveDeltaY);
                        if (dist > JOYSTICK_RADIUS) {
                            moveDeltaX *= JOYSTICK_RADIUS / dist;
                            moveDeltaY *= JOYSTICK_RADIUS / dist;
                        }

                        // ジョイスティックベクトルの更新 (-1.0 to 1.0)
                        joystickVec.x = moveDeltaX / JOYSTICK_RADIUS;
                        joystickVec.y = moveDeltaY / JOYSTICK_RADIUS;

                        // サムの位置を更新 (CSS)
                        if (joystickThumbElement) {
                             // Y軸は画面座標系なので、上向き移動のためにはマイナス方向が適切
                             // しかし、CSSのtranslateは画面座標系なので、DeltaYをそのまま使う
                             joystickThumbElement.style.transform = `translate(${moveDeltaX}px, ${moveDeltaY}px)`;
                        }

                    } else if (activeTouch.type === 'look') {
                        // 視点移動処理 (スワイプ)
                        // スワイプ方向の定義: Xは左右、Yは上下。
                        lookX += pos.x - activeTouch.startX;
                        lookY += pos.y - activeTouch.startY;
                        
                        // スワイプ視点移動後、次のフレームのために開始位置を更新して連続的なスワイプを可能にする
                        activeTouch.startX = activeTouch.currentX;
                        activeTouch.startY = activeTouch.currentY;
                    }
                }
            }
            
            // スワイプによる視点移動を適用
            if (lookX !== 0 || lookY !== 0) {
                 // X軸デルタ (横方向) で Y軸回転 (左右を見る)
                 player.rotation.y -= lookX * TOUCH_LOOK_SENSITIVITY;
                 // Y軸デルタ (縦方向) で X軸回転 (上下を見る)
                 camera.rotation.x -= lookY * TOUCH_LOOK_SENSITIVITY;
                 clampCameraPitch();
            }

            event.preventDefault();
        }

        function handleTouchEnd(event) {
            if (gameState !== 'playing') return;

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const activeTouch = activeTouches[touch.identifier];

                if (activeTouch && activeTouch.type === 'move') {
                    // ジョイスティックを中央に戻す
                    joystickVec = { x: 0, y: 0 };
                    if (joystickThumbElement) {
                        joystickThumbElement.style.transform = `translate(0, 0)`;
                    }
                }
                
                delete activeTouches[touch.identifier];
            }
        }
        
        function clampCameraPitch() {
             const maxPitch = Math.PI / 2 - 0.01;
             const minPitch = -Math.PI / 2 + 0.01;
             camera.rotation.x = Math.max(minPitch, Math.min(maxPitch, camera.rotation.x));
        }

        // --- ゲームループ & 更新ロジック ---

        function animate() {
            animationId = requestAnimationFrame(animate);

            if (gameState !== 'playing') return;

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000; // 秒単位
            lastFrameTime = currentTime;
            
            updateGame(deltaTime); 

            updateUI(deltaTime);

            renderScene();
        }

        function updateGame(deltaTime) {
            // ダッシュ速度の計算
            let currentSpeed = BASE_MOVEMENT_SPEED;
            if (isDashing) {
                currentSpeed *= DASH_MULTIPLIER;
            }
            
            // 移動速度は単位/秒で計算し、deltaTimeを乗算
            const speed = currentSpeed * deltaTime;
            let moveX = 0;
            let moveZ = 0;
            
            const angle = player.rotation.y;
            
            // --- 1. キーボード/マウス入力による移動 ---
            // W: 前進, S: 後退
            if (keys['w']) { 
                moveX += Math.sin(angle) * speed;
                moveZ += Math.cos(angle) * speed;
            }
            if (keys['s']) { 
                moveX -= Math.sin(angle) * speed;
                moveZ -= Math.cos(angle) * speed;
            }
            // A: 左平行移動, D: 右平行移動
            if (keys['a']) { 
                moveX += Math.sin(angle - Math.PI / 2) * speed * 0.5; // (角度+90度)の方向に移動
                moveZ += Math.cos(angle - Math.PI / 2) * speed * 0.5;
            }
            if (keys['d']) { 
                moveX -= Math.sin(angle - Math.PI / 2) * speed * 0.5; // (角度-90度)の方向に移動
                moveZ -= Math.cos(angle - Math.PI / 2) * speed * 0.5;
            }

            // --- 2. タッチ/ジョイスティック入力による移動 ---
            if (joystickVec.x !== 0 || joystickVec.y !== 0) {
                // Y軸(ジョイスティック縦): 前後移動 (Y軸は画面座標で上向きがマイナスなので、反転させる)
                const forward = -joystickVec.y * speed; 
                // X軸(ジョイスティック横): 左右平行移動
                const right = joystickVec.x * speed * 0.5; 

                // 前後方向の移動
                moveX += Math.sin(angle) * forward;
                moveZ += Math.cos(angle) * forward;
                
                // 左右方向の平行移動 (角度から90度ずらす)
                moveX += Math.sin(angle + Math.PI / 2) * right; 
                moveZ += Math.cos(angle + Math.PI / 2) * right;
            }
            
            // --- 3. キーボード/矢印キーによる視点移動 ---
            const rotationSpeed = KEYBOARD_ROTATION_SPEED; 
            
            if (keys['arrowleft']) {
                player.rotation.y += rotationSpeed;
            }
            if (keys['arrowright']) {
                player.rotation.y -= rotationSpeed;
            }
            if (keys['arrowup']) {
                camera.rotation.x += rotationSpeed * 0.5; 
            }
            if (keys['arrowdown']) {
                camera.rotation.x -= rotationSpeed * 0.5;
            }
            clampCameraPitch();


            // --- 4. 衝突判定と移動の適用 ---
            let newX = player.position.x + moveX;
            let newZ = player.position.z + moveZ;
            
            // X方向の移動
            if (!isWallCollision(newX, player.position.z)) {
                player.position.x = newX;
            } 
            // Z方向の移動
            if (!isWallCollision(player.position.x, newZ)) {
                player.position.z = newZ;
            } 
            
            // プレイヤーマーカーの位置と向きを同期
            playerMarker.position.x = player.position.x;
            playerMarker.position.z = player.position.z;
            playerMarker.rotation.z = -player.rotation.y; // ミニマップではZ軸回転で向きを表現


            // 敵の更新 (変更なし)
            enemies.forEach(enemy => {
                if (enemy.mesh && enemy.mesh.visible) {
                    const dx = player.position.x - enemy.mesh.position.x;
                    const dz = player.position.z - enemy.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);

                    if (dist > 1) { 
                        const factor = 0.5 * deltaTime; 
                        enemy.mesh.position.x += dx / dist * factor;
                        enemy.mesh.position.z += dz / dist * factor;
                        
                        enemy.mesh.rotation.y = Math.atan2(dx, dz);
                    } else if (dist < 0.5) {
                        // 簡易的なゲームオーバー判定
                        showGameOverScreen();
                    }
                }
            });
        }

        // --- 描画/UI ---

        function findClosestObstacle() {
            let minDistance = Infinity;
            let playerX = player.position.x;
            let playerZ = player.position.z;

            for (let z = 0; z < MAP_SIZE; z++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    if (DUNGEON_MAP[z][x] === 1) { 
                        const wallWorldX = (x - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2;
                        const wallWorldZ = (z - MAP_SIZE / 2) * CELL_SIZE + CELL_SIZE / 2;

                        const dx = wallWorldX - playerX;
                        const dz = wallWorldZ - playerZ;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        const distanceToWallEdge = distance - CELL_SIZE / 2;
                        
                        if (distanceToWallEdge > 0 && distanceToWallEdge < minDistance) {
                            minDistance = distanceToWallEdge;
                        }
                    }
                }
            }
            return { distance: minDistance === Infinity ? 0 : minDistance };
        }

        function renderScene() {
            const mainWidth = renderer.domElement.width;
            const mainHeight = renderer.domElement.height;
            
            // 1. メインカメラのレンダリング
            renderer.setViewport(0, 0, mainWidth, mainHeight);
            renderer.setScissor(0, 0, mainWidth, mainHeight);
            renderer.setClearColor(0x111827, 1);
            renderer.clear();
            
            playerMarker.visible = false; // メインビューではマーカーを非表示
            renderer.render(scene, camera);
            playerMarker.visible = true;  // ミニマップのために再表示

            // 2. ミニマップカメラのレンダリング (画面右上)
            const mapContainer = document.getElementById('minimap-container');
            if (mapContainer) {
                const mapSize = mapContainer.clientWidth;
                // CSSで右上に固定されているため、座標を計算
                // mapX, mapYはウィンドウ座標系ではなく、キャンバス内の相対座標系
                const mapX = mainWidth - mapSize - 20;
                const mapY = mainHeight - mapSize - 20; 

                renderer.setViewport(mapX, mapY, mapSize, mapSize);
                renderer.setScissor(mapX, mapY, mapSize, mapSize);
                renderer.setScissorTest(true);

                renderer.setClearColor(0x1f2937, 1);
                renderer.clear();

                minimapCamera.position.x = player.position.x;
                minimapCamera.position.z = player.position.z;
                
                renderer.render(scene, minimapCamera);
                
                renderer.setScissorTest(false);
            }
        }

        function updateUI(deltaTime) {
            const currentTime = performance.now();
            if (lastUpdateTime > 0) {
                const fps = 1000 / (currentTime - lastUpdateTime);
                document.getElementById('fps-display').textContent = Math.round(fps);
            }
            lastUpdateTime = currentTime;

            document.getElementById('pos-x').textContent = player.position.x.toFixed(2);
            document.getElementById('pos-z').textContent = player.position.z.toFixed(2);
            document.getElementById('dash-status').textContent = isDashing ? 'ON (1.5x)' : 'OFF (1.0x)';
            document.getElementById('dash-status').className = isDashing ? 'text-red-400' : 'text-green-400';
            
            const closest = findClosestObstacle();
            document.getElementById('nearest-obstacle').textContent = `最寄りの障害物: ${closest.distance.toFixed(2)} m`;
        }

        // --- タイトルメニュー処理 ---

        function handleModeSelection(selectedMode) {
            currentMode = selectedMode;
            const buttons = document.querySelectorAll('.mode-option');
            buttons.forEach(button => {
                if (button.dataset.mode === selectedMode) {
                    button.style.backgroundColor = '#0d9488'; // teal-600
                } else {
                    button.style.backgroundColor = 'rgb(55, 65, 81)'; // gray-700
                }
            });
            logMessage(`ゲームモードを「${currentMode === 'plunder' ? '盗掘' : currentMode === 'endless' ? 'エンドレス' : 'ストーリー'}」に設定しました。`, 'info');
        }


        // --- エントリポイント ---
        window.onload = function () {
            initFirebase();
            
            // タイトル画面のイベントリスナー
            document.getElementById('menu-new-game').addEventListener('click', startGame, false);
            document.getElementById('restart-button').addEventListener('click', startGame, false);
            document.getElementById('menu-controls').addEventListener('click', showControlModal, false);
            document.getElementById('close-modal-button').addEventListener('click', showTitleScreen, false);
            
            // モード選択のイベントリスナー
            document.querySelectorAll('.mode-option').forEach(button => {
                button.addEventListener('click', (e) => handleModeSelection(e.target.dataset.mode), false);
            });

            showTitleScreen();
            
            // 初期モードの表示を強制的に設定
            handleModeSelection(currentMode);
        }
    </script>
</body>
</html>
