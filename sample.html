<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>リアルタイム戦略ローグライク：ディープダイバー</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Firebase SDKs (必要に応じて使用。今回はThree.jsのエラー修正がメイン) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // グローバル変数として設定: メインスクリプトから参照できるようにする
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
        window.collection = collection;
        window.query = query;
        window.onSnapshot = onSnapshot;

        // Firestoreの初期化と匿名認証
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let db, auth;
        let isAuthReady = false;

        const initFirebase = async () => {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        console.log("Firebase Auth Ready. User ID:", user.uid);
                    } else {
                        console.log("Firebase Auth Ready. Signed out or Anonymous.");
                    }
                    isAuthReady = true;
                });

                window.db = db;
                window.auth = auth;

            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        };

        // window.onloadで実行
        window.addEventListener('load', initFirebase);

    </script>
    <style>
        /* カスタムCSS */
        body, html, #game-container {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
        }
        #main-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UI要素以外を操作できるようにする */
        }
        .minimap-container {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 150px;
            height: 150px;
            pointer-events: none;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5), 0 2px 4px -2px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            z-index: 10;
            /* 描画はThree.jsのレンダラービューポートで行うため、この要素自体は背景を持たない */
        }
        .stat-bar {
            height: 0.75rem;
            border-radius: 0.25rem;
        }
        .message-log {
            height: 100px;
            overflow-y: auto;
            pointer-events: all;
            background-color: rgba(17, 24, 39, 0.8); /* Darker background for log */
        }
    </style>
</head>
<body>
    <div id="game-container" class="relative w-screen h-screen">
        <canvas id="main-canvas" class="block"></canvas>

        <div id="ui-overlay" class="p-4 flex flex-col justify-between">
            <!-- Top Right: Minimap and Stats -->
            <div class="flex justify-end gap-4">
                
                <!-- Stats Panel -->
                <div class="bg-gray-800/80 p-4 rounded-lg shadow-xl text-white pointer-events-all w-64">
                    <h2 class="text-lg font-bold mb-2 text-indigo-400">ステータス</h2>
                    <div class="space-y-2">
                        <!-- HP -->
                        <div>
                            <div class="flex justify-between text-sm">
                                <span>HP: <span id="hp-value">100</span>/<span id="hp-max">100</span></span>
                            </div>
                            <div class="bg-gray-600 stat-bar">
                                <div id="hp-bar" class="bg-red-500 h-full transition-all duration-300" style="width: 100%;"></div>
                            </div>
                        </div>
                        <!-- ST (スタミナ/行動力) -->
                        <div>
                            <div class="flex justify-between text-sm">
                                <span>ST: <span id="st-value">100</span>/<span id="st-max">100</span></span>
                            </div>
                            <div class="bg-gray-600 stat-bar">
                                <div id="st-bar" class="bg-green-500 h-full transition-all duration-300" style="width: 100%;"></div>
                            </div>
                        </div>
                        <!-- Info -->
                        <div class="pt-2 text-xs text-gray-400">
                            <p>FPS: <span id="fps-display">0</span></p>
                            <p>位置: X=<span id="pos-x">0.00</span>, Z=<span id="pos-z">0.00</span></p>
                            <p id="nearest-obstacle">最寄りの障害物: N/A</p>
                        </div>
                    </div>
                </div>

                <!-- Minimap Container (Three.jsでレンダリングされる領域) -->
                <div class="minimap-container w-[200px] h-[200px]">
                    <!-- Canvas上で直接レンダリングされるため、特別な要素は不要 -->
                </div>
            </div>

            <!-- Bottom Left: Message Log and Controls -->
            <div class="flex justify-start items-end gap-4">
                <!-- Message Log -->
                <div class="message-log w-96 rounded-lg p-3 text-sm text-gray-200 shadow-xl pointer-events-all">
                    <h3 class="font-bold text-yellow-300 mb-1">メッセージログ</h3>
                    <div id="message-list" class="space-y-0.5">
                        <!-- Messages will be appended here -->
                    </div>
                </div>
                
                <!-- Controls/Action Panel -->
                <div class="bg-gray-800/80 p-3 rounded-lg shadow-xl text-white pointer-events-all">
                    <h3 class="text-md font-bold text-blue-400 mb-2">操作/アクション</h3>
                    <div class="flex gap-2">
                        <button id="reset-button" class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded transition duration-200 text-sm">ゲームリセット (R)</button>
                        <button id="action-button" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 rounded transition duration-200 text-sm">探索/アクション (F)</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 設定定数 ---
        const CELL_SIZE = 10;
        const MOVEMENT_SPEED = 5; // 単位: メートル/秒
        const ROTATION_SPEED = Math.PI; // 単位: ラジアン/秒
        const MINIMAP_SIZE = 200; // ミニマップの最大ピクセルサイズ
        const GAME_TICK_RATE = 1000; // 1秒ごとのロジック更新 (MS)

        // --- Three.js グローバル変数 ---
        let scene, camera, renderer, player, minimapCamera;
        let clock = new THREE.Clock();
        
        // requestAnimationFrame IDを管理するための変数 (これが重要)
        let requestAnimationFrameId = null; 

        // --- ゲーム状態変数 ---
        const keys = { w: false, s: false, a: false, d: false, q: false, e: false, r: false, f: false };
        let lastFrameTime = 0;
        let lastTickTime = 0;
        let playerStats = { hp: 100, maxHp: 100, st: 100, maxSt: 100 };
        
        // 仮のダンジョンマップ (0: 通路, 1: 壁, 2: プレイヤー初期位置, 3: 敵)
        const DUNGEON_MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 0, 0, 0, 0, 0, 3, 0, 1],
            [1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 3, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];

        // 敵のメッシュと情報
        const enemies = [];
        const obstacles = [];

        // --- 初期化 ---
        function initThree() {
            const canvas = document.getElementById('main-canvas');
            const { offsetWidth: width, offsetHeight: height } = canvas.parentElement;

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);

            // Main Camera (FPS視点)
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.rotation.order = 'YXZ'; // Yaw then Pitch

            // Player (メッシュとしては見えないが、衝突判定に使用)
            const geometry = new THREE.BoxGeometry(1, 2, 1);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, visible: false });
            player = new THREE.Mesh(geometry, material);
            scene.add(player);
            player.add(camera); // カメラをプレイヤーにアタッチ
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.autoClear = false; // 複数のビューポートレンダリングのため
            renderer.setScissorTest(true); // Scissorテストを有効にする

            // Minimap Camera (俯瞰)
            const mapSize = DUNGEON_MAP.length * CELL_SIZE / 2;
            minimapCamera = new THREE.OrthographicCamera(-mapSize, mapSize, mapSize, -mapSize, 0.1, 100);
            minimapCamera.position.y = 50;
            minimapCamera.lookAt(0, 0, 0);

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040, 5));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 100, 0);
            scene.add(directionalLight);

            // Resize Handler
            window.addEventListener('resize', onWindowResize, false);

            // Initial Player Position
            resetPlayerPosition();

            // Initial Enemy Setup
            setupEnemies();
        }

        function resetPlayerPosition() {
            // マップから初期位置 (2) を探し、プレイヤーを設定
            let initialX = -1, initialZ = -1;
            DUNGEON_MAP.forEach((row, z) => {
                row.forEach((cell, x) => {
                    if (cell === 2) {
                        initialX = x;
                        initialZ = z;
                    }
                });
            });

            if (initialX !== -1) {
                // セルの中心に配置
                player.position.set(
                    initialX * CELL_SIZE + CELL_SIZE / 2, 
                    1.75, // 目の高さ
                    initialZ * CELL_SIZE + CELL_SIZE / 2
                );
                // ミニマップカメラの初期位置
                minimapCamera.position.set(player.position.x, 50, player.position.z);
            }
            camera.rotation.y = 0; // 初期方向
        }

        function setupEnemies() {
            // 敵のメッシュを初期化 (今回は簡易的な球体)
            const enemyGeometry = new THREE.SphereGeometry(CELL_SIZE * 0.4, 16, 16);
            const enemyMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            
            DUNGEON_MAP.forEach((row, z) => {
                row.forEach((cell, x) => {
                    if (cell === 3) { // 敵の初期位置
                        const mesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                        mesh.position.set(
                            x * CELL_SIZE + CELL_SIZE / 2, 
                            CELL_SIZE * 0.4, 
                            z * CELL_SIZE + CELL_SIZE / 2
                        );
                        scene.add(mesh);
                        enemies.push({ 
                            mesh: mesh, 
                            hp: 50, 
                            maxHp: 50, 
                            initialPosition: new THREE.Vector3().copy(mesh.position)
                        });
                    }
                });
            });
        }

        function onWindowResize() {
            const canvas = document.getElementById('main-canvas');
            const { offsetWidth: width, offsetHeight: height } = canvas.parentElement;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            
            // ミニマップカメラのサイズ更新
            const mapSize = DUNGEON_MAP.length * CELL_SIZE / 2;
            minimapCamera.left = -mapSize;
            minimapCamera.right = mapSize;
            minimapCamera.top = mapSize;
            minimapCamera.bottom = -mapSize;
            minimapCamera.updateProjectionMatrix();

            render(); // サイズ変更後に一度レンダリング
        }

        function generateDungeonGeometry() {
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x5a67d8 });
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x1f2937 });
            const wallHeight = CELL_SIZE * 2;

            DUNGEON_MAP.forEach((row, z) => {
                row.forEach((cell, x) => {
                    const posX = x * CELL_SIZE + CELL_SIZE / 2;
                    const posZ = z * CELL_SIZE + CELL_SIZE / 2;

                    // Floor
                    const floorGeometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
                    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                    floorMesh.rotation.x = -Math.PI / 2;
                    floorMesh.position.set(posX, 0, posZ);
                    scene.add(floorMesh);

                    // Wall
                    if (cell === 1) {
                        const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, wallHeight, CELL_SIZE);
                        const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallMesh.position.set(posX, wallHeight / 2, posZ);
                        scene.add(wallMesh);
                        obstacles.push(wallMesh);
                    }
                });
            });
        }
        
        // --- 衝突判定ヘルパー ---
        function checkCollision(nextX, nextZ) {
            const mapX = Math.floor(nextX / CELL_SIZE);
            const mapZ = Math.floor(nextZ / CELL_SIZE);

            if (mapZ < 0 || mapZ >= DUNGEON_MAP.length || mapX < 0 || mapX >= DUNGEON_MAP[0].length) {
                return true; // マップ外は壁
            }

            return DUNGEON_MAP[mapZ][mapX] === 1; // 1は壁
        }

        // --- ゲームロジック更新 (リアルタイム進行) ---
        function updateGame(deltaTime) {
            const moveStep = MOVEMENT_SPEED * deltaTime;
            const rotStep = ROTATION_SPEED * deltaTime;

            // 1. 入力処理と移動
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0; // Y軸方向の移動を無視 (水平移動のみ)
            forward.normalize();
            
            const right = new THREE.Vector3().crossVectors(camera.up, forward).normalize();
            
            const oldX = player.position.x;
            const oldZ = player.position.z;
            let newX = oldX;
            let newZ = oldZ;

            if (keys.w) { newX += forward.x * moveStep; newZ += forward.z * moveStep; }
            if (keys.s) { newX -= forward.x * moveStep; newZ -= forward.z * moveStep; }
            if (keys.a) { newX -= right.x * moveStep; newZ -= right.z * moveStep; }
            if (keys.d) { newX += right.x * moveStep; newZ += right.z * moveStep; }

            // 衝突判定
            if (!checkCollision(newX, oldZ)) {
                player.position.x = newX;
            }
            if (!checkCollision(oldX, newZ)) {
                player.position.z = newZ;
            }

            // 旋回 (Q/Eキー)
            if (keys.q) { camera.rotation.y += rotStep; }
            if (keys.e) { camera.rotation.y -= rotStep; }
            
            // 2. ミニマップカメラの追従
            minimapCamera.position.x = player.position.x;
            minimapCamera.position.z = player.position.z;
            
            // 3. 敵の更新 (簡易的な処理)
            enemies.forEach(enemy => {
                if (enemy.hp > 0) {
                    // プレイヤーの方向を向く (簡易AI)
                    enemy.mesh.lookAt(player.position.x, enemy.mesh.position.y, player.position.z);
                    // 敵の移動ロジックなどをここに実装...
                }
            });

            // 4. リアルタイム・ティック処理
            const currentTime = performance.now();
            if (currentTime - lastTickTime >= GAME_TICK_RATE) {
                // ST回復、敵の本格的な行動判定など
                playerStats.st = Math.min(playerStats.maxSt, playerStats.st + 5); // 5 ST回復
                logMessage(`STが ${playerStats.st} に回復しました。`, 'st');
                
                // 敵にダメージを与える (仮)
                enemies.forEach(enemy => {
                    if (enemy.hp > 0) {
                        // enemy.hp -= 1; 
                        // if (enemy.hp <= 0) enemy.mesh.visible = false;
                    }
                });

                lastTickTime = currentTime;
            }
        }

        // --- レンダリング ---
        function render() {
            const canvas = renderer.domElement;
            const mainWidth = canvas.clientWidth;
            const mainHeight = canvas.clientHeight;

            // 1. メインカメラのレンダリング
            renderer.setViewport(0, 0, mainWidth, mainHeight);
            renderer.setScissor(0, 0, mainWidth, mainHeight);
            renderer.setClearColor(scene.background, 1);
            renderer.clear();
            renderer.render(scene, camera);

            // 2. ミニマップカメラのレンダリング (画面右上)
            // レスポンシブなサイズと位置を計算
            const MINIMAP_VIEWPORT_SIZE = 200; // ピクセルサイズ
            const mapSize = Math.min(MINIMAP_VIEWPORT_SIZE, mainWidth / 4, mainHeight / 4); 
            const mapX = mainWidth - mapSize - 20; // 右から20px
            const mapY = 20; // 上から20px 

            renderer.setViewport(mapX, mainHeight - mapY - mapSize, mapSize, mapSize);
            renderer.setScissor(mapX, mainHeight - mapY - mapSize, mapSize, mapSize);

            // ミニマップの背景
            renderer.setClearColor(0x1f2937, 1);
            renderer.clear();

            // ミニマップをレンダリング
            renderer.render(scene, minimapCamera);
        }

        // --- UI Updates ---
        let lastUpdateTime = 0;
        function findClosestObstacle() {
            let minDistance = Infinity;
            obstacles.forEach(obstacle => {
                const distance = player.position.distanceTo(obstacle.position) - CELL_SIZE * 0.7; // プレイヤーの体積と壁のオフセットを考慮
                if (distance > 0 && distance < minDistance) {
                    minDistance = distance;
                }
            });
            return { distance: minDistance === Infinity ? 0 : minDistance };
        }

        function updateUI(deltaTime) {
            // FPS計算
            const currentTime = performance.now();
            if (lastUpdateTime > 0) {
                const fps = 1000 / (currentTime - lastUpdateTime);
                document.getElementById('fps-display').textContent = Math.round(fps);
            }
            lastUpdateTime = currentTime;

            // 座標更新
            document.getElementById('pos-x').textContent = player.position.x.toFixed(2);
            document.getElementById('pos-z').textContent = player.position.z.toFixed(2);
            
            // ステータスバー更新
            const updateBar = (id, current, max) => {
                document.getElementById(`${id}-value`).textContent = current;
                const percent = (current / max) * 100;
                document.getElementById(`${id}-bar`).style.width = `${percent}%`;
            };

            updateBar('hp', playerStats.hp, playerStats.maxHp);
            updateBar('st', playerStats.st, playerStats.maxSt);
            
            // 最寄りの障害物情報
            const closest = findClosestObstacle();
            document.getElementById('nearest-obstacle').textContent = `最寄りの障害物: ${closest.distance.toFixed(2)} m`;
        }

        function logMessage(message, type = 'general') {
            const logList = document.getElementById('message-list');
            const p = document.createElement('p');
            p.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            let colorClass = 'text-gray-200';
            if (type === 'info') colorClass = 'text-green-400';
            if (type === 'error') colorClass = 'text-red-500';
            if (type === 'st') colorClass = 'text-green-300';
            
            p.className = `text-xs ${colorClass}`;
            
            if (logList.firstChild) {
                logList.insertBefore(p, logList.firstChild);
            } else {
                logList.appendChild(p);
            }
            // ログの最大数を制限 (例: 10個)
            while (logList.children.length > 10) {
                logList.removeChild(logList.lastChild);
            }
        }
        
        // --- 修正されたゲームループ関数 ---
        function animate(time) {
            // !!! ここが重要 !!!
            // requestAnimationFrameで自身をスケジュールすることで無限再帰を防ぐ
            requestAnimationFrameId = requestAnimationFrame(animate); 

            // 時間計測
            const deltaTime = clock.getDelta();

            // ゲームロジックの更新
            updateGame(deltaTime);

            // 描画
            render();

            // UIの更新
            updateUI(deltaTime);
        }
        
        // --- イベントハンドラ ---
        function handleKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case 'w': keys.w = true; break;
                case 's': keys.s = true; break;
                case 'a': keys.a = true; break;
                case 'd': keys.d = true; break;
                case 'q': keys.q = true; break;
                case 'e': keys.e = true; break;
                case 'r': // リセット
                    if (keys.r === false) { resetGame(); }
                    keys.r = true; 
                    break;
                case 'f': // アクション
                    if (keys.f === false) { logMessage("アクションを実行しました！", 'info'); }
                    keys.f = true;
                    break;
            }
        }

        function handleKeyUp(event) {
            switch(event.key.toLowerCase()) {
                case 'w': keys.w = false; break;
                case 's': keys.s = false; break;
                case 'a': keys.a = false; break;
                case 'd': keys.d = false; break;
                case 'q': keys.q = false; break;
                case 'e': keys.e = false; break;
                case 'r': keys.r = false; break;
                case 'f': keys.f = false; break;
            }
        }
        
        function resetGame() {
            logMessage("ゲームをリセットしました。", 'error');
            
            // 既存のアニメーションループがあれば停止する
            if (requestAnimationFrameId) {
                cancelAnimationFrame(requestAnimationFrameId);
                requestAnimationFrameId = null;
            }

            // プレイヤーと統計をリセット
            playerStats = { hp: 100, maxHp: 100, st: 100, maxSt: 100 };
            resetPlayerPosition();

            // 敵の状態をリセット (メッシュのvisible/positionも)
            enemies.forEach(enemy => {
                 if (enemy.mesh) {
                     enemy.hp = enemy.maxHp;
                     enemy.mesh.visible = true;
                     enemy.mesh.position.copy(enemy.initialPosition); // 初期位置に戻す
                 }
            });

            // 時間をリセットしてアニメーションを再開
            clock = new THREE.Clock(); // clockをリセット
            lastFrameTime = performance.now();
            lastTickTime = performance.now();
            requestAnimationFrameId = requestAnimationFrame(animate); // requestAnimationFrameで開始
        }
        
        // --- エントリポイント ---
        window.onload = function () {
            initThree();
            generateDungeonGeometry();
            
            // イベントリスナー
            document.addEventListener('keydown', handleKeyDown, false);
            document.addEventListener('keyup', handleKeyUp, false);
            document.getElementById('reset-button').addEventListener('click', resetGame, false);
            document.getElementById('action-button').addEventListener('click', () => logMessage("アクションを実行しました！", 'info'), false);
            
            // 初回描画とゲームループ開始
            logMessage("リアルタイム戦略ローグライク「Deep Diver」起動。", 'info');
            logMessage(`移動速度: ${MOVEMENT_SPEED.toFixed(2)} / 旋回速度: ${ROTATION_SPEED.toFixed(2)}`, 'info');
            
            // !!! ここも重要: requestAnimationFrameでループを開始する !!!
            requestAnimationFrameId = requestAnimationFrame(animate);
        }

    </script>
</body>
</html>
