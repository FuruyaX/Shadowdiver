<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>リアルタイム戦略ローグライク：ディープダイバー</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- カスタムCSS -->
    <style>
        body, html, #game-container {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background */
        }
        #main-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UI要素以外を操作できるようにする */
        }
        .minimap-container {
            /* ミニマップのスタイル */
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 150px;
            height: 150px;
            border: 2px solid #374151; /* gray-700 */
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            pointer-events: auto; /* クリック可能に戻す */
        }
        .log-message-box {
            max-height: 150px;
            overflow-y: auto;
            pointer-events: none;
        }
        /* スクロールバーのスタイル調整 */
        .log-message-box::-webkit-scrollbar {
            width: 6px;
        }
        .log-message-box::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 3px;
        }
        .joystick-container {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            pointer-events: auto; /* タッチ操作を有効にする */
            display: none; /* 初期状態では非表示 */
        }
        .joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
        }
    </style>
</head>
<body class="select-none">
    <!-- メインのゲームコンテナ -->
    <div id="game-container" class="relative w-full h-full">
        <canvas id="main-canvas"></canvas>
        
        <!-- UIオーバーレイ -->
        <div id="ui-overlay" class="text-white p-4 flex flex-col justify-between">
            <!-- 上部UI (ステータスバー, ミニマップ) -->
            <div class="flex justify-between items-start w-full">
                <!-- ステータスバー -->
                <div id="status-bar" class="bg-gray-800/80 p-3 rounded-xl shadow-lg pointer-events-auto flex flex-col space-y-2">
                    <div id="status-hp" class="text-sm font-bold">HP: 100/100</div>
                    <div id="status-st" class="text-sm font-bold">ST: 100/100</div>
                    <div id="status-mov" class="text-sm font-bold">MOV: 10</div>
                    <div id="status-floor" class="text-sm font-bold">階層: B1F</div>
                </div>
                <!-- ミニマップコンテナ -->
                <div class="minimap-container shadow-2xl">
                    <canvas id="minimap-canvas" class="rounded-lg"></canvas>
                </div>
            </div>

            <!-- 下部UI (アクション/インベントリ, メッセージログ) -->
            <div class="flex justify-between items-end w-full">
                <!-- アクション/インベントリ -->
                <div id="action-inventory" class="bg-gray-800/80 p-3 rounded-xl shadow-lg pointer-events-auto flex space-x-2">
                    <button class="action-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition" data-action="attack">攻撃 (Z)</button>
                    <button class="action-button bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition" data-action="item1">アイテム1 (X)</button>
                    <button class="action-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition" data-action="item2">アイテム2 (C)</button>
                </div>
                <!-- メッセージログ -->
                <div id="message-log" class="w-1/3 bg-gray-800/80 p-3 rounded-xl shadow-lg pointer-events-auto log-message-box">
                    <!-- ログメッセージがここに追加されます -->
                </div>
            </div>

            <!-- 仮想ジョイスティック (モバイル用) -->
            <div id="joystick-container" class="joystick-container">
                <div id="joystick-handle" class="joystick-handle"></div>
            </div>
        </div>

        <!-- タイトル画面 -->
        <div id="title-screen" class="absolute inset-0 bg-gray-900/95 flex flex-col items-center justify-center space-y-8 transition-opacity duration-500">
            <h1 class="text-6xl font-extrabold text-white tracking-widest">DEEP DIVER</h1>
            <p class="text-xl text-gray-400">リアルタイム戦略ローグライク</p>
            
            <div id="mode-selection" class="flex space-x-4">
                <button data-mode="story" class="mode-option bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-200">
                    ストーリー
                </button>
                <button data-mode="plunder" class="mode-option bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-200">
                    盗掘
                </button>
                <button data-mode="endless" class="mode-option bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-xl shadow-lg transition duration-200">
                    エンドレス
                </button>
            </div>
            
            <div class="flex flex-col space-y-4 w-64">
                <button id="menu-new-game" class="bg-red-600 hover:bg-red-700 text-white font-bold py-4 rounded-xl shadow-xl transition duration-200 text-lg">
                    ゲームスタート
                </button>
                <button id="menu-controls" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-xl transition duration-200">
                    操作方法
                </button>
            </div>
        </div>
        
        <!-- ゲームオーバー画面 -->
        <div id="game-over-screen" class="hidden absolute inset-0 bg-red-900/90 flex flex-col items-center justify-center space-y-8 transition-opacity duration-500">
            <h2 class="text-7xl font-extrabold text-white">GAME OVER</h2>
            <p id="game-over-reason" class="text-2xl text-red-300">HPが0になりました。</p>
            <button id="restart-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-8 rounded-xl shadow-xl transition duration-200 text-xl">
                タイトルに戻る
            </button>
        </div>

        <!-- 操作説明モーダル -->
        <div id="control-modal" class="hidden absolute inset-0 bg-gray-900/90 flex items-center justify-center">
            <div class="bg-gray-800 p-8 rounded-xl shadow-2xl w-3/4 max-w-lg space-y-6">
                <h2 class="text-3xl font-bold text-white border-b border-gray-700 pb-2">操作方法</h2>
                <div class="text-gray-300 space-y-3">
                    <p><strong>移動:</strong> W, A, S, D キー</p>
                    <p><strong>旋回:</strong> マウス移動 または 仮想ジョイスティック</p>
                    <p><strong>攻撃:</strong> Z キー</p>
                    <p><strong>アイテム使用:</strong> X, C キー</p>
                    <p class="text-sm text-yellow-400">※ モバイル端末では、画面左下のジョイスティックで移動、画面右側をスワイプで視点変更します。</p>
                </div>
                <button id="close-modal-button" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-xl transition duration-200">
                    閉じる
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- グローバル定数 ---
        const CELL_SIZE = 10;
        const MOVEMENT_SPEED = 0.5; // 1ティックあたりの移動量
        const ROTATION_SPEED = 0.05; // 旋回速度
        const MAP_WIDTH = 10;
        const MAP_HEIGHT = 10;
        const GAME_TICK_RATE = 1000; // 1秒間に1000ms
        const LOG_MAX_LINES = 5;
        const PLAYER_HEIGHT = 5;

        // --- THREE.js変数 ---
        let scene, camera, renderer, clock;
        let ambientLight, pointLight;
        let lastFrameTime = 0;
        let lastTickTime = 0;
        let animationFrameId = null; // requestAnimationFrame ID

        // --- ゲーム状態変数 ---
        let gameState = 'title'; // 'title', 'game', 'pause', 'gameover'
        let currentMode = 'story'; // 'story', 'plunder', 'endless'
        let currentFloor = 1;
        
        // --- プレイヤー/マップ変数 ---
        let keys = {}; // 押されているキー
        let player = {
            mesh: null, // Three.jsのカメラ
            hp: 100,
            maxHp: 100,
            st: 100,
            maxSt: 100,
            mov: 10,
            x: 1.5 * CELL_SIZE, // 初期位置 (x, z)
            z: 1.5 * CELL_SIZE,
            rotation: 0, // ラジアン
            isMoving: false,
        };

        // ダミーのダンジョンマップ (1:壁, 2:床, 3:敵, 4:スタート, 5:階段)
        let DUNGEON_MAP = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 4, 2, 2, 2, 2, 2, 3, 2, 1],
            [1, 2, 1, 1, 1, 1, 1, 2, 2, 1],
            [1, 2, 1, 2, 2, 2, 1, 2, 1, 1],
            [1, 2, 2, 2, 1, 2, 2, 2, 2, 1],
            [1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 1, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 5, 2, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        let wallMeshGroup; // 全ての壁メッシュを格納するグループ

        // ダミーの敵データ
        let enemies = [
            { id: 1, hp: 20, maxHp: 20, mesh: null, x: 7.5 * CELL_SIZE, z: 1.5 * CELL_SIZE, isDead: false },
        ];


        // --- Firebase/Firestore変数 ---
        let app, db, auth, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        /**
         * @brief メッセージログに新しいメッセージを追加し、表示を更新する。
         * @param {string} message - 表示するメッセージ
         * @param {string} type - 'info', 'warning', 'error', 'system' など
         */
        function logMessage(message, type = 'system') {
            const logElement = document.getElementById('message-log');
            if (!logElement) return;

            const time = new Date().toLocaleTimeString();
            const logLine = document.createElement('p');
            logLine.className = `text-xs ${type === 'error' ? 'text-red-400' : type === 'warning' ? 'text-yellow-400' : 'text-gray-200'}`;
            logLine.innerHTML = `[${time}] ${message}`;

            // 最新のメッセージを一番上に追加
            logElement.prepend(logLine);

            // 最大行数を超えたら古いものを削除
            while (logElement.children.length > LOG_MAX_LINES) {
                logElement.removeChild(logElement.lastChild);
            }
        }

        // --- Firebase初期化 ---
        async function initFirebase() {
            if (!firebaseConfig) {
                logMessage("Firebase設定が見つかりません。データ永続化は無効です。", 'warning');
                return;
            }
            
            try {
                // グローバルに公開されたFirebaseモジュールを使用
                const { initializeApp, getAuth, signInWithCustomToken, signInAnonymously, getFirestore, setLogLevel } = window;
                
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // ログレベル設定 (デバッグ用)
                setLogLevel('Debug');

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                
                userId = auth.currentUser.uid;
                logMessage(`Firebase認証成功。UserID: ${userId}`, 'info');

            } catch (error) {
                console.error("Firebase初期化エラー:", error);
                logMessage(`Firebase初期化エラー: ${error.message.substring(0, 50)}...`, 'error');
            }
        }

        // --- Three.js初期化 ---
        function initThree() {
            const container = document.getElementById('game-container');
            const canvas = document.getElementById('main-canvas');

            // 1. シーンの作成
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333); // 暗いダンジョンの背景色

            // 2. カメラの作成
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            
            // プレイヤーグループを作成し、カメラをその子にすることで移動と視点変更を分離
            player.mesh = new THREE.Group();
            player.mesh.add(camera);
            scene.add(player.mesh);

            // カメラの位置調整
            camera.position.set(0, PLAYER_HEIGHT, 0); 
            player.mesh.position.set(player.x, 0, player.z);

            // 3. レンダラーの作成
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // 4. 光源の追加
            ambientLight = new THREE.AmbientLight(0x404040, 3); // 全体的な環境光 (強め)
            scene.add(ambientLight);

            // プレイヤーの位置にポイントライトを設置
            pointLight = new THREE.PointLight(0xffffff, 1.5, 50, 2); // 懐中電灯のような光
            camera.add(pointLight); // カメラの子にすることで一緒に動く
            
            // 5. リサイズイベント
            window.addEventListener('resize', onWindowResize, false);

            logMessage("Three.js初期化完了。", 'system');
        }
        
        // --- リサイズ処理 ---
        function onWindowResize() {
            const container = document.getElementById('game-container');
            if (camera && renderer && container) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }
        
        /**
         * @brief 衝突判定。新しい位置が壁ではないかチェック。
         * @param {number} x - 試行するワールドX座標
         * @param {number} z - 試行するワールドZ座標
         * @returns {boolean} - 衝突 (壁) があれば true
         */
        function isColliding(x, z) {
            // グリッド座標に変換
            const mapX = Math.floor(x / CELL_SIZE);
            const mapZ = Math.floor(z / CELL_SIZE);
            
            // マップ範囲外チェック
            if (mapX < 0 || mapX >= MAP_WIDTH || mapZ < 0 || mapZ >= MAP_HEIGHT) {
                return true; // 衝突
            }

            // マップデータチェック (1:壁)
            return DUNGEON_MAP[mapZ][mapX] === 1;
        }

        /**
         * @brief ダミーダンジョンの3Dジオメトリを生成
         */
        function generateDungeonGeometry() {
            if (wallMeshGroup) {
                scene.remove(wallMeshGroup);
            }
            wallMeshGroup = new THREE.Group();
            
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, CELL_SIZE, 1); // 壁の基本形状 (厚さ1)
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });

            const floorGeometry = new THREE.PlaneGeometry(MAP_WIDTH * CELL_SIZE, MAP_HEIGHT * CELL_SIZE);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2; // XZ平面に配置
            floorMesh.position.set((MAP_WIDTH * CELL_SIZE) / 2 - CELL_SIZE / 2, 0, (MAP_HEIGHT * CELL_SIZE) / 2 - CELL_SIZE / 2);
            scene.add(floorMesh);
            
            // 壁とオブジェクトの配置
            for (let z = 0; z < MAP_HEIGHT; z++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const type = DUNGEON_MAP[z][x];
                    const posX = x * CELL_SIZE;
                    const posZ = z * CELL_SIZE;

                    if (type === 1) { // 壁
                        // 4方向の壁を生成 (ダンジョンの見た目を考慮して)
                        
                        // X方向の壁 (東)
                        const wallE = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallE.rotation.y = Math.PI / 2;
                        wallE.position.set(posX + CELL_SIZE / 2, CELL_SIZE / 2, posZ);
                        wallMeshGroup.add(wallE);

                        // X方向の壁 (西)
                        const wallW = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallW.rotation.y = Math.PI / 2;
                        wallW.position.set(posX - CELL_SIZE / 2, CELL_SIZE / 2, posZ);
                        wallMeshGroup.add(wallW);

                        // Z方向の壁 (北)
                        const wallN = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallN.position.set(posX, CELL_SIZE / 2, posZ - CELL_SIZE / 2);
                        wallMeshGroup.add(wallN);

                        // Z方向の壁 (南)
                        const wallS = new THREE.Mesh(wallGeometry, wallMaterial);
                        wallS.position.set(posX, CELL_SIZE / 2, posZ + CELL_SIZE / 2);
                        wallMeshGroup.add(wallS);
                        
                    } else if (type === 3) { // 敵の初期位置
                        // 敵メッシュを作成
                        const enemyGeometry = new THREE.CylinderGeometry(CELL_SIZE * 0.3, CELL_SIZE * 0.3, CELL_SIZE * 0.5, 32);
                        const enemyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                        const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                        enemyMesh.position.set(posX, CELL_SIZE * 0.5 / 2, posZ);
                        scene.add(enemyMesh);
                        enemies[0].mesh = enemyMesh; // ダミー敵にメッシュを割り当て
                    } else if (type === 4) { // スタート地点
                        player.mesh.position.set(posX, 0, posZ); // プレイヤー位置を更新
                        player.x = posX;
                        player.z = posZ;
                    }
                }
            }
            
            // 壁グループをシーンに追加
            scene.add(wallMeshGroup);
            logMessage("ダンジョンジオメトリ生成完了。", 'system');
        }

        // --- ゲームループ関連 ---
        
        /**
         * @brief 状態に基づいてゲームを更新 (フレームごと)
         * @param {number} deltaTime - 前フレームからの経過時間 (秒)
         */
        function updateGame(deltaTime) {
            if (gameState !== 'game') return;

            // 1. プレイヤーの移動と衝突判定
            
            let moveVector = new THREE.Vector3();
            let rotDelta = 0;

            // 前後移動
            if (keys['w'] || keys['W'] || keys['ArrowUp']) {
                moveVector.z -= MOVEMENT_SPEED * deltaTime * CELL_SIZE;
            }
            if (keys['s'] || keys['S'] || keys['ArrowDown']) {
                moveVector.z += MOVEMENT_SPEED * deltaTime * CELL_SIZE;
            }

            // 左右旋回 (Three.jsの回転)
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                rotDelta += ROTATION_SPEED * deltaTime * 60; // 60は概算のFPS
            }
            if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                rotDelta -= ROTATION_SPEED * deltaTime * 60;
            }
            
            // 移動をプレイヤーの向きに合わせて回転
            if (moveVector.z !== 0 || rotDelta !== 0) {
                player.isMoving = true;
                
                // 回転を適用
                player.mesh.rotation.y += rotDelta;

                // 移動ベクトルをプレイヤーの現在の回転に合わせて変換
                moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.mesh.rotation.y);
                
                const newX = player.x + moveVector.x;
                const newZ = player.z + moveVector.z;
                
                // 衝突判定 (X軸)
                if (!isColliding(newX, player.z)) {
                    player.x = newX;
                }
                
                // 衝突判定 (Z軸)
                if (!isColliding(player.x, newZ)) {
                    player.z = newZ;
                }

                // プレイヤーメッシュの位置を更新
                player.mesh.position.set(player.x, 0, player.z);

            } else {
                player.isMoving = false;
            }

            // 2. 敵の更新 (簡易的な追跡)
            enemies.forEach(enemy => {
                if (enemy.mesh && !enemy.isDead) {
                    // 敵の簡易AI：プレイヤーに向かって移動 (Three.jsのベクトルを使用)
                    const targetPosition = player.mesh.position.clone();
                    const enemyPosition = enemy.mesh.position.clone();
                    
                    const direction = targetPosition.sub(enemyPosition).normalize();
                    const moveStep = 0.5 * deltaTime; // 敵の移動速度
                    
                    // 衝突判定は省略。ここでは単純に移動させる。
                    enemy.mesh.position.add(direction.multiplyScalar(moveStep));

                    // 敵がプレイヤーに近づきすぎたらダメージ処理 (簡易)
                    if (enemy.mesh.position.distanceTo(player.mesh.position) < CELL_SIZE * 0.5) {
                        player.hp -= 1;
                        logMessage(`敵に接触！HPが${player.hp}になりました。`, 'warning');
                        if (player.hp <= 0) {
                            showGameOverScreen("敵に倒されました。");
                        }
                    }
                }
            });

            // 3. 定期的なゲームロジック (Tick処理)
            const currentTime = performance.now();
            if (currentTime - lastTickTime >= GAME_TICK_RATE) {
                // ST回復
                if (player.st < player.maxSt) {
                    player.st = Math.min(player.maxSt, player.st + 5);
                }
                
                // 追跡者のヘイト減少など (今回は未実装)

                lastTickTime = currentTime;
            }
            
            // 4. UIの更新
            renderUI();
        }

        /**
         * @brief アニメーションループ (requestAnimationFrame)
         */
        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000; // 秒単位
            lastFrameTime = currentTime;

            updateGame(deltaTime);

            renderer.render(scene, camera);
        }
        
        // --- UIレンダリング ---
        function renderUI() {
            // ステータス更新
            document.getElementById('status-hp').textContent = `HP: ${player.hp}/${player.maxHp}`;
            document.getElementById('status-st').textContent = `ST: ${player.st}/${player.maxSt}`;
            document.getElementById('status-mov').textContent = `MOV: ${player.mov}`;
            document.getElementById('status-floor').textContent = `階層: B${currentFloor}F`;

            // ミニマップの描画 (ここでは実装を省略。キャンバスAPIで描画が必要)
        }

        // --- 画面遷移制御 ---
        function showTitleScreen() {
            gameState = 'title';
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            document.getElementById('title-screen').classList.remove('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('ui-overlay').classList.add('hidden');
            document.getElementById('joystick-container').style.display = 'none';

            logMessage("タイトル画面を表示しました。", 'system');
        }

        function showGameScreen() {
            gameState = 'game';
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('ui-overlay').classList.remove('hidden');
            
            // モバイル判定でジョイスティックを表示
            if ('ontouchstart' in window || navigator.maxTouchPoints) {
                 document.getElementById('joystick-container').style.display = 'block';
            }
            
            // ゲームループ開始
            lastFrameTime = performance.now();
            lastTickTime = performance.now();
            animate();
            logMessage("ゲームを開始しました。", 'info');
        }
        
        function showGameOverScreen(reason) {
            gameState = 'gameover';
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            document.getElementById('game-over-reason').textContent = reason;
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('ui-overlay').classList.add('hidden');
            document.getElementById('joystick-container').style.display = 'none';

            logMessage("ゲームオーバー。", 'error');
        }

        function showControlModal() {
            gameState = 'pause';
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            document.getElementById('control-modal').classList.remove('hidden');
        }

        // --- ゲーム開始/リスタート処理 ---
        function startGame() {
            // ゲーム状態のリセット
            player.hp = player.maxHp;
            player.st = player.maxSt;
            currentFloor = 1;

            // マップの再生成とジオメトリの再配置
            // generateDungeonMap(); // 実際にはランダム生成が必要
            generateDungeonGeometry(); // ジオメトリを再配置 (現在は固定マップ)

            // 敵の状態をリセット (メッシュのvisible/positionも)
            enemies.forEach(enemy => {
                 if (enemy.mesh) {
                    enemy.hp = enemy.maxHp;
                    enemy.isDead = false;
                    enemy.mesh.visible = true;
                    // TODO: 敵の初期位置をマップデータから取得して正確にリセットするロジックが必要
                    // 現在は固定位置に設定
                    const startMapPos = { x: 7, z: 1 };
                    enemy.mesh.position.set(startMapPos.x * CELL_SIZE, CELL_SIZE * 0.5 / 2, startMapPos.z * CELL_SIZE);
                 }
            });

            // UIを更新してゲーム画面へ
            renderUI();
            showGameScreen();
            logMessage(`モード: ${currentMode}でゲームを開始します。`, 'info');
        }
        
        // --- モード選択処理 ---
        function handleModeSelection(mode) {
            currentMode = mode;
            document.querySelectorAll('.mode-option').forEach(button => {
                if (button.dataset.mode === mode) {
                    button.classList.remove('bg-gray-700', 'hover:bg-gray-600');
                    button.classList.add('bg-red-600', 'hover:bg-red-700');
                } else {
                    button.classList.remove('bg-red-600', 'hover:bg-red-700');
                    button.classList.add('bg-gray-700', 'hover:bg-gray-600');
                }
            });
            logMessage(`ゲームモードを「${currentMode === 'plunder' ? '盗掘' : currentMode === 'endless' ? 'エンドレス' : 'ストーリー'}」に設定しました。`, 'info');
        }

        // --- キーボードイベントハンドラ ---
        function handleKeyDown(event) {
            keys[event.key.toLowerCase()] = true;
            
            if (gameState === 'game') {
                switch (event.key.toLowerCase()) {
                    case 'z': // 攻撃
                        logMessage("攻撃アクションを実行！ (ST消費)", 'action');
                        player.st = Math.max(0, player.st - 5);
                        break;
                    case 'x': // アイテム1
                        logMessage("アイテム1を使用。", 'action');
                        break;
                    case 'c': // アイテム2
                        logMessage("アイテム2を使用。", 'action');
                        break;
                    case 'escape': // ポーズ/メニュー
                        showTitleScreen();
                        break;
                }
            } else if (gameState === 'title' && event.key === 'Enter') {
                 startGame();
            }
        }

        function handleKeyUp(event) {
            keys[event.key.toLowerCase()] = false;
        }

        // --- タッチ操作 (仮想ジョイスティック) ---
        let joystickCenter = { x: 0, y: 0 };
        let joystickActive = false;
        let rightTouchId = null; // 視点操作用のタッチID
        
        function getTouchPos(e) {
            return { x: e.clientX, y: e.clientY };
        }

        function handleTouchStart(event) {
            if (gameState !== 'game') return;

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                // 左半分を移動（ジョイスティック）として扱う
                if (touchX < window.innerWidth / 2) {
                    const container = document.getElementById('joystick-container');
                    const rect = container.getBoundingClientRect();
                    joystickCenter = { 
                        x: rect.left + rect.width / 2, 
                        y: rect.top + rect.height / 2 
                    };
                    joystickActive = true;
                } 
                // 右半分を視点操作として扱う
                else if (rightTouchId === null) {
                    rightTouchId = touch.identifier;
                }
            }
        }

        function handleTouchMove(event) {
            if (gameState !== 'game') return;
            
            player.isMoving = false;
            let moveX = 0, moveY = 0; // -1 to 1

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                const touchPos = getTouchPos(touch);
                
                // ジョイスティック操作
                if (joystickActive && touchPos.x < window.innerWidth / 2) {
                    const handle = document.getElementById('joystick-handle');
                    const maxDist = 50; // ジョイスティックコンテナの半径
                    
                    const deltaX = touchPos.x - joystickCenter.x;
                    const deltaY = touchPos.y - joystickCenter.y;
                    const distance = Math.min(maxDist, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                    const angle = Math.atan2(deltaY, deltaX);

                    handle.style.left = `${50 + (distance * Math.cos(angle))}px`;
                    handle.style.top = `${50 + (distance * Math.sin(angle))}px`;
                    
                    // 移動ベクトルに変換
                    moveX = distance / maxDist * Math.cos(angle);
                    moveY = distance / maxDist * Math.sin(angle); // Yは上下移動（Three.jsのZ軸）
                    
                    // 仮想キープレスに変換 (W, A, S, D)
                    keys['w'] = moveY < -0.2;
                    keys['s'] = moveY > 0.2;
                    // A/Dは旋回ではなく、横移動に使う場合はkeys['a'] = moveX < -0.2; keys['d'] = moveX > 0.2; となります。
                    // FPS/TPSではW/Sで前後、A/Dで旋回/カニ歩きが多いので、ここではキーボード操作に合わせます。
                    // タッチ操作では、ジョイスティックの左右は旋回に合わせます。
                    keys['a'] = moveX < -0.2;
                    keys['d'] = moveX > 0.2;
                    player.isMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'];
                }
                
                // 視点操作
                if (touch.identifier === rightTouchId) {
                    // 視点移動の処理は、キーボードのA/Dに合わせるのではなく、直接回転させるのが一般的だが、
                    // ここでは簡易的にマウス移動と同様の処理を模倣する (タッチ操作の座標変化で回転を決定)
                    if (touch.previousClientX) {
                        const deltaX = touch.clientX - touch.previousClientX;
                        player.mesh.rotation.y -= deltaX * 0.005; // 視点旋回
                    }
                    touch.previousClientX = touch.clientX;
                }
            }
        }

        function handleTouchEnd(event) {
            if (gameState !== 'game') return;

            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                
                // ジョイスティック操作終了
                if (joystickActive && touch.clientX < window.innerWidth / 2) {
                    joystickActive = false;
                    const handle = document.getElementById('joystick-handle');
                    handle.style.left = '50%';
                    handle.style.top = '50%';
                    keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
                    player.isMoving = false;
                }
                
                // 視点操作終了
                if (touch.identifier === rightTouchId) {
                    rightTouchId = null;
                }
            }
        }

        // --- エントリポイント ---
        window.onload = function () {
            // Firebaseモジュールが読み込まれているか確認
            if (typeof window.initializeApp === 'function') {
                initFirebase();
            } else {
                logMessage("Firebaseモジュールが読み込まれていません。ゲームデータ永続化は動作しません。", 'error');
            }
            
            initThree(); // Three.jsの初期化
            generateDungeonGeometry(); // ダミーマップのジオメトリを生成
            
            // タイトル画面のイベントリスナー
            document.getElementById('menu-new-game').addEventListener('click', startGame, false);
            document.getElementById('restart-button').addEventListener('click', showTitleScreen, false); // ゲームオーバーからタイトルへ
            document.getElementById('menu-controls').addEventListener('click', showControlModal, false);
            document.getElementById('close-modal-button').addEventListener('click', showTitleScreen, false);
            
            // モード選択のイベントリスナー
            document.querySelectorAll('.mode-option').forEach(button => {
                button.addEventListener('click', (e) => handleModeSelection(e.target.dataset.mode), false);
            });

            // アクションボタンのイベントリスナー
            document.querySelectorAll('.action-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    if (gameState === 'game') {
                        const action = e.target.dataset.action;
                        // キーボードイベントハンドラと同じロジックを呼び出す
                        handleKeyDown({ key: action === 'attack' ? 'z' : action === 'item1' ? 'x' : 'c' });
                        handleKeyUp({ key: action === 'attack' ? 'z' : action === 'item1' ? 'x' : 'c' });
                    }
                }, false);
            });

            // キーボードイベントリスナー
            document.addEventListener('keydown', handleKeyDown, false);
            document.addEventListener('keyup', handleKeyUp, false);
            
            // タッチイベントリスナー (モバイル対応)
            document.addEventListener('touchstart', handleTouchStart, false);
            document.addEventListener('touchmove', handleTouchMove, false);
            document.addEventListener('touchend', handleTouchEnd, false);
            
            // 初期画面表示とモード設定
            showTitleScreen();
            handleModeSelection(currentMode); // 初期モードの表示を強制的に設定
            
            logMessage("リアルタイム戦略ローグライク「Deep Diver」起動。", 'info');
        }
    </script>
</body>
</html>