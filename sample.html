<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Deep Diver - Realtime Strategy Roguelike</title>

    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* 背景色を完全な黒ではなく濃いグレーにして、レンダリングエラーと区別しやすく変更 */
        body { margin: 0; overflow: hidden; background-color: #111; touch-action: none; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* UI Overlay Styling */
        .ui-layer { pointer-events: none; position: absolute; width: 100%; height: 100%; }
        .interactive { pointer-events: auto; }
        
        /* [Source: 15] UIを全体的に小さく、被らないように配置 */
        .joystick-area { position: absolute; bottom: 20px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.1); border-radius: 50%; pointer-events: auto; }
        .joystick-knob { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; background: rgba(255, 255, 255, 0.5); border-radius: 50%; transform: translate(-50%, -50%); }
        
        /* [Source: 11] ミニマップ: 画面上部右角 */
        #minimap-container { position: absolute; top: 10px; right: 10px; width: 150px; height: 150px; background: rgba(0, 0, 0, 0.8); border: 2px solid #333; border-radius: 5px; }
        
        /* [Source: 21] UIオーバーレイ: メッセージログ等 */
        #message-log { position: absolute; bottom: 160px; left: 10px; width: 300px; max-height: 150px; overflow-y: hidden; color: #fff; font-size: 12px; text-shadow: 1px 1px 0 #000; display: flex; flex-direction: column-reverse; }
        .log-entry { margin-bottom: 2px; background: rgba(0,0,0,0.3); padding: 2px; }

        /* Start Screen */
        #title-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; color: white; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

<div id="game-container"></div>

<div class="ui-layer">
    <div id="minimap-container">
        <canvas id="minimap-canvas" width="150" height="150"></canvas>
    </div>

    <div class="absolute top-2 left-2 text-white font-mono text-sm bg-black/50 p-2 rounded">
        <div id="floor-display">Floor: 1</div>
        <div id="hp-display">HP: 100/100</div>
        <div id="st-display">ST: 100/100</div>
        <div id="mode-display">Mode: Story</div>
    </div>

    <div id="message-log"></div>

    <div id="stick-left" class="joystick-area interactive" style="bottom: 20px; left: 20px;">
        <div class="joystick-knob"></div>
    </div>

    <div class="absolute bottom-5 right-5 flex flex-col gap-4 interactive">
        <button id="btn-attack" class="w-16 h-16 bg-red-600 rounded-full text-white font-bold shadow-lg active:scale-95">ATK</button>
        <button id="btn-dash" class="w-14 h-14 bg-blue-600 rounded-full text-white font-bold shadow-lg active:scale-95">DASH</button>
        <button id="btn-item" class="w-14 h-14 bg-yellow-600 rounded-full text-white font-bold shadow-lg active:scale-95">ITEM</button>
    </div>
    
    <div id="camera-touch-zone" class="absolute top-0 right-0 w-1/2 h-3/4 interactive" style="touch-action: none;"></div>
</div>

<div id="title-screen">
    <h1 class="text-4xl font-bold mb-4 text-green-400">[ Deep Diver ]</h1>
    <p class="mb-8 text-gray-300">Realtime Strategy Roguelike</p>
    
    <div class="flex gap-4 mb-8">
        <button class="mode-btn bg-gray-700 hover:bg-green-700 text-white py-2 px-4 rounded border border-green-500" data-mode="story">ストーリー</button>
        <button class="mode-btn bg-gray-700 hover:bg-green-700 text-white py-2 px-4 rounded" data-mode="heist">盗掘 (TimeAttack)</button>
        <button class="mode-btn bg-gray-700 hover:bg-green-700 text-white py-2 px-4 rounded" data-mode="endless">エンドレス</button>
    </div>
    
    <div id="selected-mode-desc" class="mb-8 text-sm text-gray-400 h-10 text-center">
        特定のアイテムの取得を目指すモード
    </div>

    <button id="start-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded text-xl shadow-[0_0_15px_rgba(0,255,0,0.5)]">
        DIVE START
    </button>

    <p class="mt-8 text-xs text-gray-500">PC: WASD Move, Arrows Camera, Space Attack, Shift Dash<br>Mobile: Left Stick Move, Right Slide Camera</p>
</div>

<script type="module">
    import * as THREE from 'three';

    // ==========================================
    // [Source: 6] グローバル定数・設定
    // ==========================================
    const SETTINGS = {
        FOV: 75,
        PLAYER_SPEED: 0.15, // [Source: 14] 移動速度は比較的速め
        DASH_MULTIPLIER: 2.0,
        PLAYER_SIZE: 0.4,
        ENEMY_SIZE: 0.4,
        // [修正] フォグの開始位置を遠くし、手前が見えるように変更
        FOG_NEAR: 8, 
        FOG_FAR: 25,  // [Source: 12] 視界制限・フォグ
        GRID_SIZE: 40, // ダンジョン全体のグリッドサイズ
        ROOM_MIN_SIZE: 4,
        STALKER_RESPAWN_TIME: 10000, // ms
    };

    // [Source: 13] 外見・色設定
    const COLORS = {
        PLAYER: 0x00ff00, // 緑
        ENEMY: 0x0000ff,  // 青
        STALKER: 0x000000,// 黒
        ITEM: 0xffff00,   // 黄色
        ATTACK_PREVIEW: 0xffcccc, // 薄い赤
        WALL: 0x888888,   // [修正] 壁の色を明るく
        FLOOR: 0x444444   // [修正] 床の色を明るく
    };

    // グローバルステート
    const state = {
        isPlaying: false,
        mode: 'story', // [Source: 22] デフォルトはストーリー
        floor: 1,
        score: 0,
        targetItemCount: 0, // 盗掘モード用
        entities: [],
        particles: [],
        dungeon: [], // 2D Grid: 0=Wall, 1=Floor
        rooms: [],
        clock: new THREE.Clock(),
        cameraAngle: 0,
        mapRevealed: false,
        stalkerExists: false,
        keys: {},
        touch: {
            leftStick: { active: false, originX: 0, originY: 0, x: 0, y: 0 },
            camera: { active: false, lastX: 0 }
        }
    };

    // Three.js オブジェクト
    let scene, camera, renderer, playerMesh, minimapCtx;

    // ==========================================
    // ユーティリティ・初期化
    // ==========================================
    
    function init() {
        try {
            const container = document.getElementById('game-container');
            scene = new THREE.Scene();
            // [Source: 12] フォグの設定
            // [修正] フォグの色を少し明るいグレーにして、完全な暗闇を防ぐ
            scene.background = new THREE.Color(0x111111); 
            scene.fog = new THREE.Fog(0x111111, SETTINGS.FOG_NEAR, SETTINGS.FOG_FAR);

            camera = new THREE.PerspectiveCamera(SETTINGS.FOV, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // パフォーマンス調整
            container.appendChild(renderer.domElement);
            
            // // Lighting
            // const ambientLight = new THREE.AmbientLight(0x404040, 2); // 明るめ
            // scene.add(ambientLight);
            // const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            // dirLight.position.set(0, 10, 5);
            // scene.add(dirLight);

            // Minimap Context
            const minimapCanvas = document.getElementById('minimap-canvas');
            minimapCtx = minimapCanvas.getContext('2d');

            // Event Listeners
            setupInputs();
            setupUI();

            // Start Loop
            requestAnimationFrame(animate);
            
            logMessage("System initialized.");

        } catch (e) {
            console.error("Initialization Error:", e);
            alert("ゲームの起動に失敗しました。" + e.message);
        }
    }

    function setupUI() {
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('border-green-500'));
                e.target.classList.add('border-green-500');
                state.mode = e.target.dataset.mode;
                
                const descMap = {
                    story: "特定のアイテムの取得を目指すモード",
                    heist: "一定数のアイテムを取得するまでのタイムアタック",
                    endless: "より深い階層を目指して無限に潜り続けるモード"
                };
                document.getElementById('selected-mode-desc').innerText = descMap[state.mode];
            });
        });

        // Start Button
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('title-screen').style.display = 'none';
            startGame();
        });
    }

    // ==========================================
    // [Source: 9] ダンジョン生成 (BSP法)
    // ==========================================
    class BSPNode {
        constructor(x, y, w, h) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.left = null; this.right = null;
            this.room = null;
        }

        split() {
            if (this.left || this.right) return false; // 既に分割済み

            // 縦横どちらに分割するかランダム決定
            let splitH = Math.random() > 0.5;
            if (this.w > this.h && this.w / this.h >= 1.25) splitH = false;
            else if (this.h > this.w && this.h / this.w >= 1.25) splitH = true;

            const max = (splitH ? this.h : this.w) - SETTINGS.ROOM_MIN_SIZE;
            if (max <= SETTINGS.ROOM_MIN_SIZE) return false; // 分割スペースなし

            const splitAt = Math.floor(Math.random() * (max - SETTINGS.ROOM_MIN_SIZE)) + SETTINGS.ROOM_MIN_SIZE;

            if (splitH) {
                this.left = new BSPNode(this.x, this.y, this.w, splitAt);
                this.right = new BSPNode(this.x, this.y + splitAt, this.w, this.h - splitAt);
            } else {
                this.left = new BSPNode(this.x, this.y, splitAt, this.h);
                this.right = new BSPNode(this.x + splitAt, this.y, this.w - splitAt, this.h);
            }
            return true;
        }

        createRooms() {
            if (this.left || this.right) {
                if (this.left) this.left.createRooms();
                if (this.right) this.right.createRooms();
            } else {
                // 葉ノードに部屋を作る
                const roomW = Math.floor(Math.random() * (this.w - 2)) + 2;
                const roomH = Math.floor(Math.random() * (this.h - 2)) + 2;
                const roomX = Math.floor(Math.random() * (this.w - roomW)) + this.x + 1;
                const roomY = Math.floor(Math.random() * (this.h - roomH)) + this.y + 1;
                this.room = { x: roomX, y: roomY, w: roomW, h: roomH };
                state.rooms.push(this.room);
            }
        }
    }

    function generateDungeon(floor) {
        // リセット: 全オブジェクト削除
        // [Source: 7] 実装コードではThree.jsの標準ジオメトリで代替。古いメッシュを破棄
        while(scene.children.length > 0){ 
            scene.remove(scene.children[0]); 
        }
        
        // [修正] プレイヤーメッシュの参照もリセット（再作成させるため）
        // これを行わないと、削除されたメッシュを操作し続けて画面に映らない
        playerMesh = null;

        // ライト再配置 (明るめに設定)
        const amb = new THREE.AmbientLight(0xffffff, 1.5); // [修正] 強度アップ
        scene.add(amb);
        const dl = new THREE.DirectionalLight(0xffffff, 2); // [修正] 強度アップ
        dl.position.set(10, 20, 10);
        scene.add(dl);

        state.dungeon = Array(SETTINGS.GRID_SIZE).fill().map(() => Array(SETTINGS.GRID_SIZE).fill(0));
        state.rooms = [];
        state.entities = [];

        // BSP実行
        const root = new BSPNode(1, 1, SETTINGS.GRID_SIZE - 2, SETTINGS.GRID_SIZE - 2);
        const iterations = 4; 
        let nodes = [root];
        for (let i = 0; i < iterations; i++) {
            let newNodes = [];
            nodes.forEach(n => {
                if (n.split()) newNodes.push(n.left, n.right);
                else newNodes.push(n);
            });
            nodes = newNodes;
        }
        root.createRooms();

        // マップデータ書き込み
        // グリッドに部屋を反映
        state.rooms.forEach(r => {
            for (let y = r.y; y < r.y + r.h; y++) {
                for (let x = r.x; x < r.x + r.w; x++) {
                    state.dungeon[y][x] = 1; // Floor
                }
            }
        });

        // 通路生成 (単純化: 部屋の中心同士を繋ぐL字通路)
        for (let i = 0; i < state.rooms.length - 1; i++) {
            const r1 = state.rooms[i];
            const r2 = state.rooms[i + 1];
            const c1 = { x: Math.floor(r1.x + r1.w/2), y: Math.floor(r1.y + r1.h/2) };
            const c2 = { x: Math.floor(r2.x + r2.w/2), y: Math.floor(r2.y + r2.h/2) };

            // 水平
            const xStart = Math.min(c1.x, c2.x);
            const xEnd = Math.max(c1.x, c2.x);
            for(let x=xStart; x<=xEnd; x++) state.dungeon[c1.y][x] = 1;

            // 垂直
            const yStart = Math.min(c1.y, c2.y);
            const yEnd = Math.max(c1.y, c2.y);
            for(let y=yStart; y<=yEnd; y++) state.dungeon[y][c2.x] = 1;
        }

        // 3Dモデル生成
        buildDungeonMesh();

        // プレイヤー配置
        const startRoom = state.rooms[0];
        spawnPlayer(startRoom.x + 1, startRoom.y + 1);

        // [Source: 9] 階段、アイテム配置
        const endRoom = state.rooms[state.rooms.length - 1];
        spawnEntity('stairs', endRoom.x + 1, endRoom.y + 1);

        // [Source: 9] 罠、敵、アイテムをランダム配置
        // [Source: 9] 罠は避けて通れるように配置（簡易実装: 部屋の中央付近のみなど）
        state.rooms.forEach((r, idx) => {
            if(idx === 0 || idx === state.rooms.length - 1) return; // スタートとゴールは除外
            // 敵
            if(Math.random() > 0.3) spawnEntity('enemy', r.x + Math.floor(r.w/2), r.y + Math.floor(r.h/2));
            // アイテム
            if(Math.random() > 0.6) spawnEntity('item', r.x + 1, r.y + 1);
            // 罠
            if(Math.random() > 0.7) spawnEntity('trap', r.x + r.w - 2, r.y + r.h - 2);
        });

        // [Source: 17] 追跡者: 新規階層突入時にランダム配置
        const stalkerRoomIdx = Math.floor(Math.random() * (state.rooms.length - 2)) + 1;
        const sRoom = state.rooms[stalkerRoomIdx];
        // 初期はスポーンしない、または離れた場所にスポーン。今回は最初からスポーンさせる
        spawnEntity('stalker', sRoom.x + 2, sRoom.y + 2);

        logMessage(`Floor ${floor} reached.`);
        document.getElementById('floor-display').innerText = `Floor: ${floor}`;
    }

    function buildDungeonMesh() {
        // [修正] MeshStandardMaterialに変更して光の反応を良くする
        // 単純化のため、CubeGeometryを統合せず個別に配置（最適化の余地ありだが要件範囲内）
        const wallGeo = new THREE.BoxGeometry(1, 2, 1);
        const wallMat = new THREE.MeshStandardMaterial({ color: COLORS.WALL, roughness: 0.8 });
        const floorGeo = new THREE.PlaneGeometry(1, 1);
        const floorMat = new THREE.MeshStandardMaterial({ color: COLORS.FLOOR, roughness: 0.8 });
        
        const group = new THREE.Group();

        for (let y = 0; y < SETTINGS.GRID_SIZE; y++) {
            for (let x = 0; x < SETTINGS.GRID_SIZE; x++) {
                if (state.dungeon[y][x] === 0) {
                    // Wall (少しランダムな高さにして見た目を改善)
                    const h = 1.5 + Math.random() * 0.5;
                    // 壁の当たり判定は論理グリッドで行うため、ここでは視覚表現のみ
                    // パフォーマンスのため、床に隣接する壁のみ描画等の処理をすべきだが、今回は全描画
                    // 壁の高さをランダムにして洞窟感を出すのもあり
                    const wall = new THREE.Mesh(wallGeo, wallMat);
                    wall.scale.y = h; 
                    wall.position.set(x, h/2, y);
                    group.add(wall);
                } else {
                    // Floor
                    const floor = new THREE.Mesh(floorGeo, floorMat);
                    floor.rotation.x = -Math.PI / 2;
                    floor.position.set(x, 0, y);
                    group.add(floor);
                }
            }
        }
        scene.add(group);
    }

    // ==========================================
    // エンティティ管理 (Player, Enemy, Items)
    // ==========================================
    class Entity {
        constructor(type, x, y) {
            this.type = type;
            this.x = x;
            this.y = y;
            this.z = 0.5; // 浮遊高さ
            this.mesh = null;
            this.active = true;
            this.hp = 100;
            // this.maxHp = 100;
            
            this.initMesh();
        }

        initMesh() {
            // [Source: 7] 実装コードではThree.jsの標準ジオメトリで代替
            // [Source: 13] プレイヤーは球体、敵は立方体
            let geo, mat;
            switch(this.type) {
                case 'player':
                    geo = new THREE.SphereGeometry(SETTINGS.PLAYER_SIZE, 16, 16);
                    mat = new THREE.MeshStandardMaterial({ color: COLORS.PLAYER, emissive: 0x004400 });
                    break;
                case 'enemy':
                    geo = new THREE.BoxGeometry(SETTINGS.ENEMY_SIZE, SETTINGS.ENEMY_SIZE, SETTINGS.ENEMY_SIZE);
                    mat = new THREE.MeshStandardMaterial({ color: COLORS.ENEMY });
                    break;
                case 'stalker':
                    geo = new THREE.BoxGeometry(SETTINGS.ENEMY_SIZE * 1.5, SETTINGS.ENEMY_SIZE * 1.5, SETTINGS.ENEMY_SIZE * 1.5);
                    mat = new THREE.MeshStandardMaterial({ color: COLORS.STALKER });
                    break;
                case 'item':
                    geo = new THREE.OctahedronGeometry(0.2);
                    mat = new THREE.MeshBasicMaterial({ color: COLORS.ITEM, wireframe: true });
                    break;
                case 'stairs':
                    geo = new THREE.ConeGeometry(0.3, 1, 4);
                    mat = new THREE.MeshLambertMaterial({ color: 0xffffff });
                    break;
                case 'trap':
                    // [Source: 13] 罠は床の色で表現（ここではわかりやすく赤い平面を少し浮かす）
                    geo = new THREE.PlaneGeometry(0.8, 0.8);
                    mat = new THREE.MeshBasicMaterial({ color: 0x550000 });
                    this.z = 0.05; // 床スレスレ
                    break;
            }

            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.position.set(this.x, this.z, this.y);
            if(this.type === 'trap') this.mesh.rotation.x = -Math.PI/2;
            scene.add(this.mesh);

            // [Source: 13] アイテムは光で表現
            if(this.type === 'item') {
                const light = new THREE.PointLight(COLORS.ITEM, 1, 3);
                this.mesh.add(light);
            }
        }

        update(dt, time) {
            if(!this.active) return;

            // [Source: 13] アイテム、プレイヤー、敵はいずれも浮遊しており、常に上下に揺れている
            if(this.type !== 'trap' && this.type !== 'stairs') {
                this.mesh.position.y = 0.5 + Math.sin(time * 3) * 0.1;
            }

            // 位置更新
            this.mesh.position.x = this.x;
            this.mesh.position.z = this.y;
        }
    }

    // [Source: 16, 17, 18, 19] 追跡者AIの実装
    class Stalker extends Entity {
        constructor(x, y) {
            super('stalker', x, y);
            // [Source: 19] 4状態: CAUTION, CHASE, FRENZY, STOP
            this.mode = 'CAUTION';
            this.hate = 0; // [Source: 18] ヘイト値
            this.modeTimer = 0;
            this.speed = 0.03;
            this.attackRange = 1.2;
            this.attackCooldown = 0;
            // this.respawnTimer = 0;
        }

        update(dt, time) {
            super.update(dt, time);
            if(!this.active) return;

            const pDist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);

            // [Source: 18] ヘイトは時間経過で少しずつ減少
            // [Source: 19] 追跡・猛追での減少速度の違いを実装
            let decay = 5 * dt;
            if(this.mode === 'CHASE') decay = 8 * dt;
            if(this.mode === 'FRENZY') decay = 12 * dt;
            if(this.mode === 'STOP') decay = 0; // 停止中は減少しない、むしろ増える

            this.hate = Math.max(0, this.hate - decay);

            // モード遷移ロジック [Source: 19]
            switch(this.mode) {
                case 'CAUTION':
                    // ランダム移動
                    if(Math.random() < 0.02) this.moveRandom(dt);
                    
                    // [Source: 19] 接近によりヘイト蓄積
                    if(pDist < 5) this.hate += 20 * dt;

                    if(this.hate > 50) this.changeMode('CHASE');
                    break;

                case 'CHASE':
                    this.moveTowardsPlayer(dt, this.speed);
                    // 接近でヘイト蓄積
                    if(pDist < 8) this.hate += 15 * dt;

                    if(this.hate > 100 || pDist < 3) this.changeMode('FRENZY');
                    if(this.hate < 10 && pDist > 10) this.changeMode('CAUTION');
                    break;

                case 'FRENZY':
                    // [Source: 19] 移動速度増加、追跡精度向上
                    this.moveTowardsPlayer(dt, this.speed * 2.5);
                    
                    // [Source: 19] 猛追中はヘイトたまらない。一定時間で停止へ
                    this.modeTimer -= dt;
                    if(this.modeTimer <= 0) this.changeMode('STOP');
                    break;

                case 'STOP':
                    // [Source: 19] 移動しない。ヘイト大きく増加しやすい
                    // 停止中は被ダメージ増加などのデバフがあっても良いが仕様にはないので省略
                    if(pDist < 3) this.hate += 50 * dt; // 近くにいると激増
                    
                    this.modeTimer -= dt;
                    if(this.modeTimer <= 0) {
                        if(this.hate > 80) this.changeMode('FRENZY');
                        else this.changeMode('CAUTION');
                    }
                    break;
            }

            // [Source: 20] 攻撃処理
            if(pDist < this.attackRange && this.attackCooldown <= 0 && this.mode !== 'STOP') {
                this.startAttack();
            }
            if(this.attackCooldown > 0) this.attackCooldown -= dt;

            // 回転 [Source: 13] 移動時は移動方向に回転
            // 簡易的にプレイヤーの方を向く
            this.mesh.lookAt(player.x, this.mesh.position.y, player.y);
        }

        changeMode(newMode) {
            if(this.mode === newMode) return;
            this.mode = newMode;
            logMessage(`Stalker: ${newMode}`);
            if(newMode === 'FRENZY') this.modeTimer = 10; // 10秒暴れる
            if(newMode === 'STOP') this.modeTimer = 5;    // 5秒停止
        }

        moveRandom(dt) {
            // 簡易ランダム
            const dx = (Math.random() - 0.5) * dt;
            const dy = (Math.random() - 0.5) * dt;
            if(!checkCollision(this.x + dx, this.y + dy)) {
                this.x += dx;
                this.y += dy;
            }
        }

        moveTowardsPlayer(dt, speed) {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            const dx = Math.cos(angle) * speed;
            const dy = Math.sin(angle) * speed;
            
            // [Source: 9] 壁判定
            if(!checkCollision(this.x + dx, this.y + dy)) {
                this.x += dx;
                this.y += dy;
            }
        }

        startAttack() {
            // [Source: 20] 予兆表示 -> ラグ -> 判定
            this.attackCooldown = 3.0; // CD 3秒
            // 予兆メッシュ
            const indicator = new THREE.Mesh(
                new THREE.RingGeometry(0.1, 1.0, 32),
                new THREE.MeshBasicMaterial({ color: COLORS.ATTACK_PREVIEW, side: THREE.DoubleSide, transparent: true, opacity: 0.5 })
            );
            indicator.rotation.x = -Math.PI/2;
            indicator.position.set(this.x, 0.1, this.y);
            scene.add(indicator);

            // [Source: 20] 追跡者のラグは長め
            setTimeout(() => {
                scene.remove(indicator);
                if(!this.active) return;
                // 判定
                const pDist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                if(pDist < 1.0) { // 範囲内
                    damagePlayer(30); // [Source: 17] 即死の危険（大ダメージ）
                }
            }, 1000); // 1秒後発動
        }
    }

    // ==========================================
    // プレイヤー管理
    // ==========================================
    let player = {
        x: 0, y: 0, z: 0.5,
        rotation: 0,
        hp: 100, maxHp: 100,
        st: 100, maxSt: 100,
        items: 0
    };

    function spawnPlayer(x, y) {
        player.x = x;
        player.y = y;
        // [修正] playerMeshがnullの場合（シーンクリア後）は必ず再作成する
        if(!playerMesh) {
            playerMesh = new Entity('player', x, y).mesh;
        } else {
            // ここには来ないはずだが、念のため
            playerMesh.position.set(x, 0.5, y);
        }
    }

    function spawnEntity(type, x, y) {
        if(type === 'stalker') {
            const s = new Stalker(x, y);
            state.entities.push(s);
            state.stalkerExists = true;
            return;
        }
        const e = new Entity(type, x, y);
        state.entities.push(e);
    }

    // ==========================================
    // ゲームループ & ロジック
    // ==========================================
    
    function startGame() {
        state.isPlaying = true;
        state.floor = 1;
        player.hp = 100;
        player.st = 100;
        generateDungeon(state.floor);
        
        // [Source: 22] モード別初期化
        if(state.mode === 'heist') state.targetItemCount = 5;
        
        logMessage("Dive Started.");
    }

    function checkCollision(x, y) {
        // グリッド座標
        const gx = Math.round(x);
        const gy = Math.round(y);
        
        if(gx < 0 || gx >= SETTINGS.GRID_SIZE || gy < 0 || gy >= SETTINGS.GRID_SIZE) return true;
        // [Source: 9] 壁の当たり判定 (0=Wall)
        return state.dungeon[gy][gx] === 0;
    }

    function updatePlayerMovement(dt) {
        if(player.hp <= 0) return;

        let moveX = 0;
        let moveY = 0;

        // [Source: 14] キーボード入力 W/S/A/D
        if(state.keys['w']) moveY -= 1;
        if(state.keys['s']) moveY += 1;
        if(state.keys['a']) moveX -= 1;
        if(state.keys['d']) moveX += 1;

        // [Source: 14] スマホ入力 (フローティングコントローラ)
        if(state.touch.leftStick.active) {
            moveX += state.touch.leftStick.x;
            moveY += state.touch.leftStick.y;
        }

        // カメラの向きに合わせて移動ベクトルを回転
        // [Source: 11] ミニマップは北固定だが、操作はカメラ基準が直感的
        // カメラアングルは state.cameraAngle
        const sin = Math.sin(state.cameraAngle);
        const cos = Math.cos(state.cameraAngle);

        const dx = moveX * cos - moveY * sin;
        const dy = moveX * sin + moveY * cos;

        // 正規化して速度適用
        const len = Math.sqrt(dx*dx + dy*dy);
        let speed = SETTINGS.PLAYER_SPEED;
        
        // [Source: 14] ダッシュ (Shift or Button)
        const isDash = state.keys['shift'] || state.keys['dash_btn'];
        if(isDash && player.st > 0 && len > 0.1) {
            speed *= SETTINGS.DASH_MULTIPLIER;
            player.st -= 30 * dt; // ST消費
        } else {
            // [Source: 10] ST自然回復
            player.st = Math.min(player.maxSt, player.st + 10 * dt);
        }

        if(len > 0.1) {
            const nextX = player.x + (dx / len) * speed;
            const nextY = player.y + (dy / len) * speed;

            // [Source: 9] 壁判定
            if(!checkCollision(nextX, nextY)) {
                player.x = nextX;
                player.y = nextY;
                // // [Source: 13] 移動時は移動方向に回転
                // const moveAngle = Math.atan2(dy, dx);
                // // Player Mesh Rotation (visual only)
                // // playerMesh.rotation.y = -moveAngle; 
            }
        }
        // メッシュ同期
        if(playerMesh) {
            playerMesh.position.x = player.x;
            playerMesh.position.z = player.y;
        }

        // [Source: 14] カメラ操作 (PC: Arrow Keys, Mobile: Right Slide)
        if(state.keys['arrowleft']) state.cameraAngle -= 2 * dt;
        if(state.keys['arrowright']) state.cameraAngle += 2 * dt;
        // Mobile slide is handled in touch handler, updating state.cameraAngle
    }

    function updateCamera() {
       // プレイヤー追従 TPS視点
        // カメラ位置調整：プレイヤーの少し後ろ上空
        const dist = 6;
        const height = 5;
        
        const cx = player.x + Math.sin(state.cameraAngle) * dist;
        const cz = player.y + Math.cos(state.cameraAngle) * dist;
        
        camera.position.set(cx, height, cz);
        camera.lookAt(player.x, 0.5, player.y);
    }

    function updateEntities(dt, time) {
        state.entities.forEach(e => {
            e.update(dt, time);

            // プレイヤーとの接触判定
            const dist = Math.sqrt((player.x - e.x)**2 + (player.y - e.y)**2);
            
            if(dist < 0.8) {
                if(e.type === 'item' && e.active) {
                    e.active = false;
                    scene.remove(e.mesh);
                    player.items++;
                    logMessage("Item acquired!");
                    // [Source: 17] 特定の行動（アイテム取得）でヘイトを稼ぐ
                    addStalkerHate(15);

                    // 盗掘モード判定
                    if(state.mode === 'heist' && player.items >= state.targetItemCount) {
                        logMessage("Target Reached! Go to Exit!");
                    }
                }
                else if(e.type === 'trap' && e.active) {
                    // [Source: 9] 罠
                    damagePlayer(10);
                    logMessage("Trapped! HP -10");
                    e.active = false; // 一回踏んだら消える（または再利用可能にする）
                }
                else if(e.type === 'stairs') {
                    // [Source: 17] 次階層への移動条件: 追跡者が近くにいる状態で一定時間経過
                    // 簡易実装: 追跡者がフロアにいて、かつ一定距離(例えば10)以内にいる場合のみ脱出可能とする
                    // ※概要書には「追跡者が近くにいる状態で一定時間経過」とあるので、逃げ切るのではなく、あえてリスクを負う必要がある。
                    
                    const stalker = state.entities.find(ent => ent.type === 'stalker');
                    if(stalker && stalker.active) {
                        const sDist = Math.sqrt((player.x - stalker.x)**2 + (player.y - stalker.y)**2);
                        if(sDist > 15) { // 遠すぎる
                            if(Math.random() < 0.05) logMessage("Stalker is too far to exit...");
                            return; 
                        }
                    }
                    
                    nextFloor();
                }
                else if(e.type === 'enemy' && e.active) {
                    // 一般敵の接触ダメージ
                    // 攻撃の予兆システムとは別に、接触ダメージがあるか、あるいは敵AIで攻撃判定するか。
                    // ここでは簡易的に敵も攻撃予兆を持っていると仮定し、AI側で処理させるが、
                    // 雑魚敵の徘徊(Source 16)とあるので、ぶつかるとダメージを入れておく。
                    damagePlayer(1 * dt); // 継続ダメージ
                }
            }
        });
    }

    function damagePlayer(amount) {
        player.hp -= amount;
        document.getElementById('hp-display').innerText = `HP: ${Math.floor(player.hp)}/100`;
        if(player.hp <= 0) {
            logMessage("YOU DIED.");
            state.isPlaying = false;
            setTimeout(() => location.reload(), 3000);
        }
    }

    function addStalkerHate(amount) {
        const stalker = state.entities.find(e => e.type === 'stalker');
        if(stalker && stalker.active) {
            stalker.hate += amount;
            // logMessage(`Stalker Hate Increased! (${Math.floor(stalker.hate)})`);
            logMessage(`Stalker Hate Increased!`);
        }
    }

    function nextFloor() {
        state.floor++;
        
        if(state.mode === 'story' && state.floor > 5) {
            alert("Story Complete! You found the artifact.");
            location.reload();
            return;
        }
        
        generateDungeon(state.floor);
    }

    // ==========================================
    // [Source: 11] ミニマップ描画
    // ==========================================
    function drawMinimap() {
        const size = 150;
        const scale = 4; // 拡大率
        minimapCtx.fillStyle = '#000';
        minimapCtx.fillRect(0, 0, size, size);

        // マップの中心をプレイヤーにする
        minimapCtx.save();
        minimapCtx.translate(size/2, size/2);
        // [Source: 11] 北固定なので回転はさせない（プレイヤーアイコンのみ回転）
        
        // 描画範囲
        const range = 15; // 視界範囲

        // 壁・床
        minimapCtx.fillStyle = '#555';
        for(let y = Math.floor(player.y - range); y <= Math.floor(player.y + range); y++) {
            for(let x = Math.floor(player.x - range); x <= Math.floor(player.x + range); x++) {
                if(y>=0 && y<SETTINGS.GRID_SIZE && x>=0 && x<SETTINGS.GRID_SIZE) {
                    if(state.dungeon[y][x] === 1) {
                        minimapCtx.fillRect((x - player.x) * scale, (y - player.y) * scale, scale, scale);
                    }
                }
            }
        }

        // エンティティ
        state.entities.forEach(e => {
            if(!e.active) return;
            // [Source: 11] 追跡者のみ表示されない
            if(e.type === 'stalker') return;
            const mx = (e.x - player.x) * scale;
            const my = (e.y - player.y) * scale;

            // 範囲外なら描画しない
            if(Math.abs(mx) > size/2 || Math.abs(my) > size/2) return;

            if(e.type === 'item') minimapCtx.fillStyle = 'yellow';
            else if(e.type === 'enemy') minimapCtx.fillStyle = 'red';
            else if(e.type === 'stairs') minimapCtx.fillStyle = 'white';
            else if(e.type === 'trap') minimapCtx.fillStyle = 'purple'; // 罠も表示（Source 11: 罠や敵を確認可能）
            
            minimapCtx.fillRect(mx-2, my-2, 4, 4);
        });

        // プレイヤー (回転する矢印)
        minimapCtx.save();
        minimapCtx.rotate(-state.cameraAngle + Math.PI); // カメラ向きの逆？いや、カメラの向いている方向を表示
        // Source 11: 北固定で自分を示すアイコンの回転で向きを表現
        // 自分の向き＝移動方向、あるいはカメラ方向。ここではカメラ方向とする
        
        minimapCtx.fillStyle = 'lime';
        minimapCtx.beginPath();
        minimapCtx.moveTo(0, -5);
        minimapCtx.lineTo(4, 5);
        minimapCtx.lineTo(-4, 5);
        minimapCtx.fill();
        minimapCtx.restore();

        minimapCtx.restore();
    }

    function logMessage(msg) {
        const log = document.getElementById('message-log');
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerText = msg;
        log.prepend(entry);
        if(log.children.length > 5) log.lastChild.remove();
    }

    // ==========================================
    // メインループ
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);
        
        if(!state.isPlaying) return;

        const dt = state.clock.getDelta();
        const time = state.clock.getElapsedTime();

        updatePlayerMovement(dt);
        updateEntities(dt, time);
        updateCamera();
        drawMinimap();

        // [Source: 10] UI更新（ST, HP）
        document.getElementById('st-display').innerText = `ST: ${Math.floor(player.st)}/100`;
        renderer.render(scene, camera);
    }

    // ==========================================
    // 入力処理 (PC & Mobile)
    // ==========================================
    function setupInputs() {
        // PC Keyboard
        window.addEventListener('keydown', (e) => {
            state.keys[e.key.toLowerCase()] = true;
            if(e.key === ' ') performAction('attack'); // Space
        });
        window.addEventListener('keyup', (e) => state.keys[e.key.toLowerCase()] = false);

        // Mobile Touch - Left Stick (Move)
        const stick = document.getElementById('stick-left');
        const knob = stick.querySelector('.joystick-knob');
        
        stick.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            state.touch.leftStick.active = true;
            state.touch.leftStick.originX = touch.clientX;
            state.touch.leftStick.originY = touch.clientY;
        }, {passive: false});

        stick.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if(!state.touch.leftStick.active) return;
            const touch = e.changedTouches[0];
            const dx = touch.clientX - state.touch.leftStick.originX;
            const dy = touch.clientY - state.touch.leftStick.originY;
            
            // Limit distance
            const dist = Math.min(40, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            const kx = Math.cos(angle) * dist;
            const ky = Math.sin(angle) * dist;
            knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
            
            // Normalize output -1 to 1
            state.touch.leftStick.x = kx / 40;
            state.touch.leftStick.y = ky / 40;
        }, {passive: false});

        const resetStick = (e) => {
            state.touch.leftStick.active = false;
            state.touch.leftStick.x = 0;
            state.touch.leftStick.y = 0;
            knob.style.transform = `translate(-50%, -50%)`;
        };
        stick.addEventListener('touchend', resetStick);
        stick.addEventListener('touchcancel', resetStick);

        // Mobile Touch - Right Screen (Camera)
        const camZone = document.getElementById('camera-touch-zone');
        camZone.addEventListener('touchstart', (e) => {
            state.touch.camera.active = true;
            state.touch.camera.lastX = e.changedTouches[0].clientX;
        });
        camZone.addEventListener('touchmove', (e) => {
            if(!state.touch.camera.active) return;
            const cx = e.changedTouches[0].clientX;
            const dx = cx - state.touch.camera.lastX;
            state.cameraAngle += dx * 0.01; // Sensitivity
            state.touch.camera.lastX = cx;
        });
        camZone.addEventListener('touchend', () => state.touch.camera.active = false);

        // Buttons
        document.getElementById('btn-attack').addEventListener('touchstart', (e) => { e.preventDefault(); performAction('attack'); });
        document.getElementById('btn-dash').addEventListener('touchstart', (e) => { e.preventDefault(); state.keys['dash_btn'] = true; });
        document.getElementById('btn-dash').addEventListener('touchend', (e) => { e.preventDefault(); state.keys['dash_btn'] = false; });
        document.getElementById('btn-item').addEventListener('touchstart', (e) => { e.preventDefault(); performAction('item'); });
    }

    function performAction(action) {
        if(action === 'attack') {
            // [Source: 20] 自分の攻撃に予兆は表示されない
            logMessage("Attack!");
            // 近接攻撃判定
            state.entities.forEach(e => {
                if(e.active && (e.type === 'enemy' || e.type === 'stalker')) {
                    const dist = Math.sqrt((player.x - e.x)**2 + (player.y - e.y)**2);
                    if(dist < 1.5) {
                        // Hit
                        // Stalker can be defeated but respawns [Source: 17]
                        // エフェクト（簡易）
                        e.mesh.material.color.setHex(0xff0000);
                        setTimeout(() => e.mesh.material.color.setHex(e.type==='stalker' ? COLORS.STALKER : COLORS.ENEMY), 200);
                        if(e.type === 'stalker') {
                            e.active = false;
                            e.mesh.visible = false;
                            logMessage("Stalker Defeated... for now.");
                            // [Source: 17] 一定時間後にランダムな位置で復活
                            setTimeout(() => {
                                const r = state.rooms[Math.floor(Math.random() * state.rooms.length)];
                                e.x = r.x + 1; e.y = r.y + 1;
                                e.active = true;
                                e.mesh.visible = true;
                                e.hp = 100;
                                e.hate = 0;
                                e.mode = 'CAUTION';
                                logMessage("Stalker RESPAWNED!");
                            }, SETTINGS.STALKER_RESPAWN_TIME);
                        } else {
                            // Normal enemy
                            e.active = false;
                            scene.remove(e.mesh);
                        }
                    }
                }
            });
        } else if (action === 'item') {
            // マップアイテムなど
            logMessage("Item used (Stub)");
        }
    }

    // Start
    window.onload = init;

</script>
</body>
</html>